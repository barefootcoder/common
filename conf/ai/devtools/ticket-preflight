#!/usr/bin/env bash

ME=$(basename "$0")

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Exit codes
EXIT_SUCCESS=0
EXIT_VIM_UNSAVED=1
EXIT_TRIAGE_PAST=2
EXIT_TIMER_MISMATCH=3
EXIT_SHEETS_OUTDATED=4
EXIT_CONFIG_MISSING=5

# Track overall status
OVERALL_STATUS=$EXIT_SUCCESS
WARNINGS=()
ERRORS=()

# Helper functions
print_header() {
    echo -e "\n${BLUE}=== $1 ===${NC}"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
    WARNINGS+=("$1")
}

print_error() {
    echo -e "${RED}✗${NC} $1"
    ERRORS+=("$1")
    OVERALL_STATUS=$2
}

check_vim_swap() {
    local file="$1"
    local swap_file="$2"
    local name="$3"
    
    if [ -f "$swap_file" ]
    then
        # Check if swap file shows unsaved changes
        local file_info=$(file "$swap_file" 2>/dev/null)
        
        if echo "$file_info" | grep -q "modified"
        then
            print_error "$name has unsaved changes in vim!" $EXIT_VIM_UNSAVED
            echo "  Action required: Save the file in vim with :w"
            return 1
        else
            # Check if vim process is still running
            local pid=$(echo "$file_info" | grep -oP 'pid \K\d+' || true)
            if [ -n "$pid" ] && ps -p "$pid" > /dev/null 2>&1
            then
                print_success "$name is open in vim but saved (pid $pid)"
            else
                print_warning "$name has stale swap file (no active vim session)"
                echo "  Consider removing: rm $swap_file"
            fi
        fi
    else
        print_success "$name is not being edited"
    fi
    return 0
}

# Main validation script
echo -e "${BLUE}Ticket Onboarding Pre-flight Validation${NC}"
echo "========================================="

# 1. Check configuration files
print_header "Configuration Check"

if [ -f "$HOME/common/aidoc/projects/todo-management/private/user-config.md" ]
then
    print_success "User configuration found"
else
    print_error "User configuration missing at ~/common/aidoc/projects/todo-management/private/user-config.md" $EXIT_CONFIG_MISSING
fi

# 2. Check Google Sheets accessibility (requires manual verification for now)
print_header "Google Sheets Check"
echo "  Note: Sheet currency check requires API access during workflow"
print_warning "Google Sheets validation will be performed during workflow execution"

# 3. Check triage file
print_header "Triage File Check"

TRIAGE_FILE="/export/work/ce/triage.md"
TRIAGE_SWAP="/export/work/ce/.triage.md.swp"

if [ -f "$TRIAGE_FILE" ]
then
    # Check for vim swap file
    check_vim_swap "$TRIAGE_FILE" "$TRIAGE_SWAP" "Triage file"
    
    # Check triage date is in future
    if [ -r "$TRIAGE_FILE" ]
    then
        # Extract date from first non-blank line (format: "YYYY/M/D meeting")
        triage_date=$(grep -m1 -P '^\d{4}/\d{1,2}/\d{1,2}' "$TRIAGE_FILE" | grep -oP '\d{4}/\d{1,2}/\d{1,2}' || true)
        if [ -n "$triage_date" ]
        then
            # Convert YYYY/M/D to YYYY-MM-DD for comparison
            triage_date_normalized=$(date -d "$triage_date" +%Y-%m-%d 2>/dev/null || true)
            if [ -n "$triage_date_normalized" ]
            then
                today=$(date +%Y-%m-%d)
                if [[ "$triage_date_normalized" > "$today" ]]
                then
                    print_success "Triage date ($triage_date) is in the future"
                else
                    print_error "Triage date ($triage_date) is in the past!" $EXIT_TRIAGE_PAST
                    echo "  This would modify historical meeting notes"
                fi
            else
                print_warning "Could not parse triage date: $triage_date"
            fi
        else
            print_warning "Could not extract triage date from file"
        fi
    else
        print_warning "Cannot read triage file to verify date"
    fi
else
    print_warning "Triage file not found at $TRIAGE_FILE"
fi

# 4. Check timer file
print_header "Timer File Check"

TIMER_FILE="/export/work/timer/timer-new"
TIMER_SWAP="/export/work/timer/.timer-new.swp"

if [ -f "$TIMER_FILE" ]
then
    # Check for vim swap file
    check_vim_swap "$TIMER_FILE" "$TIMER_SWAP" "Timer file"
    
    # Check timer week alignment
    if [ -r "$TIMER_FILE" ]
    then
        # Find first timer chunk with timestamps (format: "name<tab>timestamp1-timestamp2,...")
        first_timestamp=$(grep -m1 -P '\t\d{10}' "$TIMER_FILE" | grep -oP '\d{10}' | head -1 || true)
        if [ -n "$first_timestamp" ]
        then
            # Convert Unix timestamp to date
            timer_date=$(date -d "@$first_timestamp" +%Y-%m-%d 2>/dev/null || true)
            if [ -n "$timer_date" ]
            then
                # Calculate which Monday this date belongs to
                timer_monday=$(date -d "$timer_date -$(date -d "$timer_date" +%u) days +1 day" +%Y-%m-%d)
                # Get current week's Monday (calculate based on day of week)
                day_of_week=$(date +%u)  # 1=Monday, 7=Sunday
                if [ "$day_of_week" -eq 1 ]; then
                    # Today is Monday
                    current_monday=$(date +%Y-%m-%d)
                elif [ "$day_of_week" -eq 7 ]; then
                    # Today is Sunday - belongs to previous week
                    current_monday=$(date -d "6 days ago" +%Y-%m-%d)
                else
                    # Tuesday through Saturday - calculate days back to Monday
                    days_back=$((day_of_week - 1))
                    current_monday=$(date -d "$days_back days ago" +%Y-%m-%d)
                fi
                
                if [ "$timer_monday" = "$current_monday" ]
                then
                    print_success "Timer file is for current week (first entry: $timer_date)"
                else
                    print_warning "Timer file appears to be for week of $timer_monday (current week: $current_monday)"
                    echo "  This might be expected if working across week boundaries"
                fi
            else
                print_warning "Could not parse timestamp: $first_timestamp"
            fi
        else
            print_warning "No timer entries found in file (might be a fresh week)"
        fi
    else
        print_warning "Cannot read timer file to verify week"
    fi
else
    print_warning "Timer file not found at $TIMER_FILE"
fi

# 5. Check time-shifted date logic
print_header "Work Date Calculation (6 AM boundary)"

HOUR=$(date '+%H')
CURRENT_TIME=$(date '+%H:%M')
ACTUAL_DATE=$(date '+%m/%d/%Y')
ACTUAL_DAY=$(date '+%A')

if [ $HOUR -lt 6 ]
then
    WORK_DATE=$(date -d "yesterday" '+%m/%d/%Y')
    WORK_DAY=$(date -d "yesterday" '+%A')
    echo "  Current time: $CURRENT_TIME $ACTUAL_DAY (before 6 AM cutoff)"
    echo "  Actual date: $ACTUAL_DATE"
    echo -e "  ${GREEN}→ Work date: $WORK_DATE ($WORK_DAY)${NC}"
    echo "  Rationale: Time before 6 AM belongs to previous day"
else
    WORK_DATE=$(date '+%m/%d/%Y')
    WORK_DAY=$(date '+%A')
    echo "  Current time: $CURRENT_TIME $ACTUAL_DAY (after 6 AM cutoff)"
    echo "  Actual date: $ACTUAL_DATE"
    echo -e "  ${GREEN}→ Work date: $WORK_DATE ($WORK_DAY)${NC}"
    echo "  Rationale: Time after 6 AM belongs to current day"
fi

# Export for use by other scripts
export TICKET_WORK_DATE="$WORK_DATE"
echo
echo -e "  ${BLUE}For ticket onboarding, use date: ${GREEN}$WORK_DATE${NC}"
print_success "Work date calculated: $WORK_DATE"

# 6. Check directory accessibility
print_header "Directory Access Check"

directories=(
    "/export/work/ce"
    "/export/work/timer"
    "$HOME/common/aidoc/projects/todo-management"
)

for dir in "${directories[@]}"
do
    if [ -d "$dir" ] && [ -r "$dir" ]
    then
        print_success "Can access: $dir"
    else
        print_warning "Cannot access: $dir (may need to be added to session)"
    fi
done

# Summary
echo
print_header "Validation Summary"

if [ ${#WARNINGS[@]} -gt 0 ]
then
    echo -e "${YELLOW}Warnings (${#WARNINGS[@]}):${NC}"
    for warning in "${WARNINGS[@]}"
    do
        echo "  - $warning"
    done
fi

if [ ${#ERRORS[@]} -gt 0 ]
then
    echo -e "${RED}Errors (${#ERRORS[@]}):${NC}"
    for error in "${ERRORS[@]}"
    do
        echo "  - $error"
    done
    echo
    echo -e "${RED}Pre-flight validation FAILED${NC}"
    echo "Please resolve the errors above before proceeding with ticket onboarding."
else
    echo -e "${GREEN}Pre-flight validation PASSED${NC}"
    if [ ${#WARNINGS[@]} -gt 0 ]
    then
        echo "There are warnings that should be reviewed, but you can proceed."
    else
        echo "All systems are ready for ticket onboarding!"
    fi
fi

exit $OVERALL_STATUS