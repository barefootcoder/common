VCtoolsDir=~/proj/VCtools

WorkingDir=~/proj
WorkingDir=~/workproj

# Policy file for CE
<<include /home/buddy/workproj/CE/etc/ceflow/CE.conf>>

DefaultVC=git
<<include ~/proj/VCtools/share/conf/git.conf>>
<<include ~/proj/VCtools/share/conf/svn.conf>>

DefaultSourcePath=git@github.com:%user/%project.git

# personal overrides for VC commands
<git>
	<commands>
		stage <<---
			git add -p %files
		---
	</commands>
</git>


<Project VCtools.svn>
    VC = svn
</Project>

<Project common>
	ProjectDir = ~/common
</Project>

<CustomCommand merge>
    Verify = project
    Files = 0

    action <<---
		%cur_branch !~ m{^feature/} -> ! Will only merge trunk into a feature branch.
		%is_dirty -> git stash save -u
		git fetch origin
		git merge origin/%Mainline
		%is_dirty -> git stash pop
    ---
</CustomCommand>


<CustomCommand stg-amend>
	Description = Amend a previous commit
    Verify = project
    Argument = how_far_back

    action <<---
		TARGET="HEAD" . '^' x %how_far_back
		`git branch -r --contains $TARGET` -> ! Cannot amend; commit has already been published.
		!%is_dirty -> ! You have no changes to apply.
		# first, save all mods
		git stash save -u "changes for stg-amend"
		# now fire up a rebase, then re-apply the mods and let the user stage some of them
		git rebase -i $TARGET
		git stash apply
		git add -i
		# now adjust the commit
		git commit -v --amend
		# now we really need to clear out all the leftover mods before proceeding
		# 1) remove any untracked files
		# 2) revert all other mods
		git status -s | perl -lne 's/^...// and unlink if /^\?\?/'
		git status -s | perl -lpe 's/^...// and `git checkout -- $_`'
		# now put back all the intervening commits, then restore any remaining mods
		git rebase --continue
		git stash pop
    ---
</CustomCommand>


# overrides for CE
<Policy CE>
	<git>
		<commands>

			# remember: %info methods record the state as of when they're first requested
			# therefore, %is_dirty will remain true (if it was before) even after the stash
			sync <<---
				%is_dirty -> git stash save -u
				git pull --rebase
				%is_dirty -> git stash pop
			---

            unbranch <<---
                = checkout trunk
            ---

			stage <<---
				CHECKTABS=`checktabs -n`
				"$CHECKTABS" -> > $CHECKTABS
				"$CHECKTABS" -> ! "fix checktabs problems before continuing"
				git add -p %files
			---

		</commands>
	</git>

	<CustomCommand merge>
		Verify = project
		Files = 0

		action <<---
			%cur_branch !~ m{^feature/} -> ! Will only merge trunk into a feature branch.
			%is_dirty -> git stash save -u
			= branch-update
			%is_dirty -> git stash pop
		---
	</CustomCommand>
</Policy>
