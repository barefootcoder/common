# THIS IS SHARED ACROSS ALL MACHINES

# personal overrides for VC commands
<git>
	<commands>
		stage <<---
			git add -p %files
		---
		unbranch <<---
			%cur_branch ne %Mainline	->	echo %cur_branch >%last_branch_file
			git checkout %Mainline
		---
	</commands>
</git>
# these really should be in the <git> block above
# but they don't work there, for some reason
	<CustomInfo last_branch_file>
		action <<---
			{ glob("~/.vctools/last_branch." . %project) }
		---
	</CustomInfo>
	<CustomCommand stat-plus>
		action <<---
			= stat
			git-helper-log -Ns origin/%Mainline..HEAD | perl -0777 -e '$o = <STDIN> and print "\nUnpushed commits:\n$o\n"'
		---
	</command>
	<CustomCommand rebranch>
		action <<---
			not -e %last_branch_file	->	! Don't know what last active branch was.
			git checkout `cat %last_branch_file`
		---
	</command>


<CustomCommand merge>
    Verify = project
    Files = 0

    action <<---
		%cur_branch !~ m{^feature/} -> ! Will only merge trunk into a feature branch.
		%is_dirty -> git stash save -u 'Local changes in effect as of `%me merge`'
		git fetch origin
		git merge origin/%Mainline
		%is_dirty -> git stash pop
    ---
</CustomCommand>


<CustomCommand chktabs>
	Description = Verify there are no tabs in modified files
    Verify = project

	action <<---
		POLICY=$self->config->policy
		"$POLICY" eq "CE" ->	CHECKTABS=`checktabs -n`
		"$POLICY" eq "CE" ->	"$CHECKTABS" -> > $CHECKTABS
		"$POLICY" eq "CE" ->	"$CHECKTABS" -> ! "fix checktabs problems before continuing"
	---
</CustomCommand>

<CustomCommand stg-amend>
	Description = Amend a previous commit
    Verify = project
    Argument = how_far_back							<integer (number of commits to go back to) or SHA1>

    action <<---
		# verify state and set up proper value for $TARGET
		= chktabs
		length(%how_far_back) >= 7	->	TARGET=%how_far_back
		length(%how_far_back) < 7	->	%how_far_back == 1 -> ! Won't do most recent commit; use `%me commit -F` instead.
		length(%how_far_back) < 7	->	TARGET="HEAD" . '^' x (%how_far_back - 1)
		`git branch -r --contains $TARGET` -> ! Cannot amend; commit has already been published.
		!%is_dirty -> > *~You have no changes to apply.~*
		!%is_dirty -> ? Are you sure you want to amend anyway?

		# first, save all mods
		STASH_MESSAGE_OUTER="changes for stg-amend"
		git stash save -u "$STASH_MESSAGE_OUTER"

		# now fire up a rebase, then, *if* the user chooses to edit a commit,
		# re-apply the mods and let the user stage some of them
		git rebase -i $TARGET^
		COMMIT_EDIT=`git status` =~ /rebase in progress/ ? 1 : 0
		$COMMIT_EDIT	->		git stash apply	|| :
		$COMMIT_EDIT	->		= unstage
		$COMMIT_EDIT	->		git add -i

		# now adjust the commit (again, *if* the user chose to edit a commit)
		$COMMIT_EDIT	->		git commit -v --amend

		# now we really need to clear out all the leftover mods before proceeding
		# the easiest (and safest) way to do that is to just stash again, then drop the stash
		$COMMIT_EDIT	->		STASH_MESSAGE_INNER="throwing away unused changes"
		$COMMIT_EDIT	->		git stash save -u "$STASH_MESSAGE_INNER"
		# note safe stash drop
		$COMMIT_EDIT	->		git stash list | grep -q "$STASH_MESSAGE_INNER" && git stash drop ||:

		# now put back all the intervening commits, then restore any remaining mods
		$COMMIT_EDIT	->		git rebase --continue
		# again, safe stash drop
		git stash list | grep -q "$STASH_MESSAGE_OUTER" && git stash pop ||:
    ---
</CustomCommand>

<CustomCommand stash-files>
	Description = Show files stored in a stash
	Verify = project
	<Trailing name>
		description = optional name ("stash@{1}") or number ("1") to identify stash
		singular = name
		qty = 0..1
	</Trailing>

	action <<---
		# make it so you can just go `vc stash-files 1`
		STASH=my $f = %name[0] // '0'; $f =~ /^\d+$/ ? sprintf('stash@{%s}', $f) : $f
		# don't forget: env expansion still takes place in single quotes
		# normally I would use double quotes just to make it more obvious, but $STASH contains an @,
		# so it will give a "Possible unintended interpolation" error if we don't use single quotes
		!system('git rev-list --quiet $STASH^3 2>/dev/null')		->	UNTRACKED='$STASH^3'
		git show $STASH $UNTRACKED --stat | grep '^ [^ ]'
	---
</CustomCommand>

<CustomCommand unstash-force>
	Description = Unstash dammit
	Verify = project
	<Trailing name>
		description = optional name ("stash@{1}") or number ("1") to identify stash
		singular = name
		qty = 0..1
	</Trailing>

	action <<---
		# make it so you can just go `vc unstash-force 1`
		STASH=my $f = %name[0] // '0'; $f =~ /^\d+$/ ? sprintf('stash@{%s}', $f) : $f
		git stash show -p $STASH | git apply
		git stash drop $STASH
	---
</CustomCommand>

<CustomCommand clean>
	Description = Remove local changes in a recoverable fashion
	Verify = project

	action <<---
		!%is_dirty	->	! Nothing to clean!
		? *~Local changes will be lost!~* (but recoverable via SHA1 of dropped stash)
		git stash save -u 'Local changes in effect as of `%me clean`'
		git stash drop
	---
</CustomCommand>

<CustomInfo remotes>
	Type = ArrayRef
	action <<---
		git remote
	---
</CustomInfo>
<CustomCommand set-upstream>
	Description = Set upstream remote for the current branch
	Verify = project
    Argument = remote								<name of remote (must exist)>

	action <<---
		#NUM_REMOTES=scalar @[(%remotes)]
		not %remote ~~ [%remotes]		->	! Remote %remote does not exist
		git fetch %remote
		git branch --set-upstream-to %remote/%cur_branch
	---
</CustomCommand>
