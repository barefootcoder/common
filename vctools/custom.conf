# THIS IS SHARED ACROSS ALL MACHINES

# personal overrides for VC commands
<git>
	<commands>
		stage <<---
			git add -p %files
		---
		unbranch <<---
			%cur_branch ne %Mainline	->	echo %cur_branch >%last_branch_file
			git checkout %Mainline
		---
	</commands>
</git>
# these really should be in the <git> block above
# but they don't work there, for some reason
	<CustomInfo last_branch_file>
		action <<---
			{ glob("~/.vctools/last_branch." . %project) }
		---
	</CustomInfo>
	<CustomCommand stat-plus>
		action <<---
			= stat
			git-helper-log -LNs | perl -0777 -e '$o = <STDIN> and print "\nUnpushed commits:\n$o\n"'
		---
	</CustomCommand>
	<CustomCommand rebranch>
		action <<---
			not -e %last_branch_file	->	! Don't know what last active branch was.
			git checkout `cat %last_branch_file`
		---
	</CustomCommand>


# This method for finding unpushed commits based on:
# http://stackoverflow.com/questions/2016901/viewing-unpushed-git-commits
#
# Unfortunately, limiting it to only the current branch turned out to be non-trivial. :-/
# You can give `--branches` an arg, but it either has to contain a wildcard, or it gets "/*"
# appended to it automatically, which makes it match nothing.  So we *have* to add the "*" at the
# end, at which point it matches.  Unfortunately, it would also match any other branch name that was
# the same as the current branch name, only longer.  For instance, if you were on branch
# feature/foo, this would match feature/foo, but also feature/foo-bar.  Which we don't want.  So we
# apply a bit of Perl magic at the end to make sure we only get the branch we're looking for.  Note
# that "%d" produces either "(feature/foo)" *or* "(HEAD -> feature/foo)"--or possibly even
# "(feature/foo, feature/bar)"--so that's why the regex is a bit more complex than you might
# imagine at first.
<CustomInfo local_commits>
	Type = ArrayRef
	action <<---
		# seems silly to shell out to `perl` when we're *running* in Perl
		# but, strangely, this code is actually simpler (and easier to follow)
		# this is partially because it relies on autosplit (-a) to do some work behind the scenes
		# but also because interpolating the %cur_branch is easier/cleaner this way
		# and, lastly, because it's easier to break into separate lines this way
		# code to do it all in Perl (not fully tested):
		#		{	my $in;
		#			join('',
		#				grep { $in = $2 eq %cur_branch if s{\s+\((.*? )?(\S+?)(,.*?)?\).*$}{}; $in }
		#				`git log --branches="${\(%cur_branch)}*" --not --remotes --pretty="%h %d"`
		#			)
		#		}
		# except you (currently) have to jam all that onto one line
		LOCAL_COMMITS_PROGLET='$i = m{\((.*? )?\Q' . %cur_branch .'\E(,.*?)?\)} if $F[1]; print $F[0] if $i'
		git log --branches="%cur_branch*" --not --remotes --pretty="%h %d" | perl -lane "$LOCAL_COMMITS_PROGLET"
	---
</CustomInfo>

<CustomInfo num_local_commits>
	Type = Str
	action <<---
		{ scalar %local_commits }
	---
</CustomInfo>


<CustomCommand merge>
	Verify = project
	Files = 0

	action <<---
		%cur_branch !~ m{^feature/} -> ! Will only merge trunk into a feature branch.
		%is_dirty -> git stash save -u 'Local changes in effect as of `%me merge`'
		git fetch origin
		git merge origin/%Mainline
		%is_dirty -> git stash pop
	---
</CustomCommand>


<CustomCommand chktabs>
	Description = Verify there are no tabs in modified files
	Verify = project

	action <<---
		POLICY=$self->config->policy || '0'
		"$POLICY" eq "CE" ->	CHECKTABS=`checktabs -n`
		"$POLICY" eq "CE" ->	"$CHECKTABS" -> > $CHECKTABS
		"$POLICY" eq "CE" ->	"$CHECKTABS" -> ! "fix checktabs problems before continuing"
	---
</CustomCommand>

<CustomCommand find-unmerged-commits>
	Description = After "not fully merged" message, see what Git thinks is not fully merged
	Verify = project
	Argument = branch_name      <unique string which appears in (pre-existing) branch name>

	action <<---
		PATTERN='*' . %branch_name . '*'
		NUM_PROSPECTS=`git branch --no-color --list "$PATTERN" | wc -l`
		# this is just to make our error message look nicer
		{ chomp $ENV{'NUM_PROSPECTS'} }
		$NUM_PROSPECTS == 0 -> ! Can't find branch matching $PATTERN.
		$NUM_PROSPECTS  > 1 -> ! Too many prospects matching $PATTERN (found $NUM_PROSPECTS).

		COMPARE_BRANCH=`git branch --no-color --list "$PATTERN"`
		git log --graph --left-right --cherry-pick --oneline %Mainline..$COMPARE_BRANCH
	---
</CustomCommand>

<CustomCommand stg-amend>
	Description = Amend a previous commit
	Verify = project
	Argument = how_far_back							<integer (number of commits to go back to) or SHA1>

	action <<---
		# verify state and set up proper value for $TARGET
		= chktabs
		length(%how_far_back) >= 7	->	TARGET=%how_far_back
		length(%how_far_back) < 7	->	%how_far_back == 1 -> ! Won't do most recent commit; use `%me commit -F` instead.
		length(%how_far_back) < 7	->	TARGET="HEAD" . '^' x (%how_far_back - 1)
		`git branch -r --contains $TARGET` -> ! Cannot amend; commit has already been published.
		!%is_dirty -> > *~You have no changes to apply.~*
		!%is_dirty -> ? Are you sure you want to amend anyway?

		# first, save all mods
		STASH_MESSAGE_OUTER="changes for stg-amend"
		git stash save -u "$STASH_MESSAGE_OUTER"

		# now fire up a rebase, then, *if* the user chooses to edit a commit,
		# re-apply the mods and let the user stage some of them
		git rebase -i $TARGET^
		COMMIT_EDIT=`git status` =~ /rebase in progress/ ? 1 : 0
		$COMMIT_EDIT	->		git stash apply	|| :
		$COMMIT_EDIT	->		= unstage
		$COMMIT_EDIT	->		git add -i

		# now adjust the commit (again, *if* the user chose to edit a commit)
		$COMMIT_EDIT	->		git commit -v --amend

		# now we really need to clear out all the leftover mods before proceeding
		# the easiest (and safest) way to do that is to just stash again, then drop the stash
		$COMMIT_EDIT	->		STASH_MESSAGE_INNER="throwing away unused changes"
		$COMMIT_EDIT	->		git stash save -u "$STASH_MESSAGE_INNER"
		# note safe stash drop
		$COMMIT_EDIT	->		git stash list | grep -q "$STASH_MESSAGE_INNER" && git stash drop ||:

		# now put back all the intervening commits, then restore any remaining mods
		$COMMIT_EDIT	->		git rebase --continue
		# again, safe stash drop
		git stash list | grep -q "$STASH_MESSAGE_OUTER" && git stash pop ||:
	---
</CustomCommand>

<CustomCommand amend-local>
	Description = Amend one commit from among all local commits
	Verify = project

	action <<---
		= chktabs
		> *-%num_local_commits local commits-*
		= stg-amend %num_local_commits
	---
</CustomCommand>

# given part of the stash message, or the stash number, find the stash name
# (this is used by many of the stash commands below; not very useful on its own)
<CustomCommand stash-identify>
	Description = Given a stash message (partial okay), return the stash name
	Verify = project
	<Trailing stashid>
		description = stash number, stash message, or partial message
		singular = stashid
		qty = 0..1
	</Trailing>

	action <<---
		# from the original version of `stash-files`
		#STASH=my $f = %name[0] // '0'; $f =~ /^\d+$/ ? sprintf('stash@{%s}', $f) : $f

		# don't forget: env expansion still takes place in single quotes
		# normally I would use double quotes just to make it more obvious, but $STASH can contain an @,
		# so it could give a "Possible unintended interpolation" error if we don't use single quotes
		STASH=""									# avoid "not defined" warning
		!"%stashid"							->	STASH='stash@{0}'
		"%stashid" =~ /^stash\@\{\d+\}$/	->	STASH="%stashid"
		"%stashid" =~ /^\d+$/				->	STASH=sprintf('stash@{%s}', "%stashid")
		!'$STASH'  							->	STASH=join(',', map { /^(.*?): .*%stashid/ ? $1 : () } `git stash list`)

		not '$STASH'						->	! Could not find the stash: %stashid
		'$STASH' =~ /,/						->	! Ambiguous stashid: $STASH
		> stash: *-$STASH-*
	---
</CustomCommand>

# override for standard unstash
<CustomCommand my-unstash>
	Description = Restore previously stashed changes, by name
	Verify = project
	<Trailing stashid>
		description = optional identifier (number/message/partial message) to identify stash
		singular = stashid
		qty = 0..1
	</Trailing>

	action <<---
		= stash-identify %stashid
		# now $STASH is set
		git stash pop $STASH
	---
</CustomCommand>

<CustomCommand stash-p>
	Description = Partial stash of uncommitted changes
	Verify = project
	Argument = message									<message to identify stash>

	action <<---
		git stash save -p "%message"
		= stat
	---
</CustomCommand>

<CustomCommand stash-files>
	Description = Show files stored in a stash
	Verify = project
	<Trailing stashid>
		description = optional identifier (number/message/partial message) to identify stash
		singular = stashid
		qty = 0..1
	</Trailing>

	action <<---
		= stash-identify %stashid
		# now $STASH is set
		# don't forget: env expansion still takes place in single quotes
		# normally I would use double quotes just to make it more obvious, but $STASH contains an @,
		# so it will give a "Possible unintended interpolation" error if we don't use single quotes
		!system('git rev-list --quiet $STASH^3 2>/dev/null')		->	UNTRACKED='$STASH^3'
		git show $STASH $UNTRACKED --stat | grep '^ [^ ]'
	---
</CustomCommand>

<CustomCommand stash-search>
	Description = Search all stashes for a string
	Verify = project
	Argument = pattern								<Perl regex to search for>

	action <<---
		SHOW_STASH='git show {}; git cat-file -t {}^3 >/dev/null 2>&1 && git show {}^3'
		git reflog --format=\%gd stash | each "$SHOW_STASH" | perl -lne "print if /%pattern/" | $PAGER
	---
</CustomCommand>

<CustomCommand unstash-force>
	Description = Unstash dammit
	Verify = project
	<Trailing stashid>
		description = optional identifier (number/message/partial message) to identify stash
		singular = stashid
		qty = 0..1
	</Trailing>

	action <<---
		= stash-identify %stashid
		# now $STASH is set
		git stash show --no-color -p $STASH | git apply
		git stash drop $STASH
	---
</CustomCommand>

<CustomCommand stash-drop>
	Description = Drop a stash, by name
	Verify = project
	Argument = stashid								<stash number or stash message (partial okay)>

	action <<---
		= stash-identify %stashid
		# now $STASH is set
		git log -1 --format=%s $STASH
		= stash-files $STASH
		? Are you sure you want to drop this stash?
		git stash drop $STASH
	---
</CustomCommand>

<CustomCommand stash-check>
	Description = Examine a stash, increasingly microscopically, without unstashing
	Verify = project
	Verify = clean
	Argument = stashid								<stash number or stash message (partial okay)>

	action <<---
		= stash-identify %stashid
		# now $STASH is set
		git log -1 --format=%s $STASH
		= stash-files $STASH
		? ...
		git stash show -p $STASH
		? Apply the stash for deeper investigation?
		git stash apply $STASH
		> *-Run this after browsing stashed changes:-*
		> *=vc clean=*
	---
</CustomCommand>

<CustomCommand clean>
	Description = Remove local changes in a recoverable fashion
	Verify = project

	action <<---
		!%is_dirty			->	! Nothing to clean!
		SHUT_UP=eval '$' . 'ENV{OKAY_TO_CLEAN} ? 1 : 0'
		!$SHUT_UP		->	? *~Local changes will be lost!~* (but recoverable via SHA1 of dropped stash)
		git reset HEAD || :
		git stash save -u 'Local changes in effect as of `%me clean`'
		git stash drop
	---
</CustomCommand>

<CustomCommand testclean>
	Description = Stash, run tests, then unstash
	Verify = project

	action <<---
		!%is_dirty	->	! Nothing to clean! (just run `t`)
		STASH_MESSAGE='Local changes in effect as of `' . %me . ' testclean`'
		git stash save -u "$STASH_MESSAGE"
		t ||:
		? *-Testing complete.-*
		OKAY_TO_CLEAN=1
		`git status` !~ /working directory clean/	->	= clean
		git stash list | grep -q "$STASH_MESSAGE" && git stash pop ||:
	---
</CustomCommand>

<CustomCommand reset-symlinks>
	Description = Revert spurious typechange modifications, often caused by Dropbox
	Verify = project

	action <<---
		FILES=join('', grep { s/^(...)// and $1 eq ' T ' } `git status --porcelain=v1`)
		not "$FILES" -> ! No typechange'd files to revert.
		> *-Will revert the following files:-*
		> *=$FILES=*
		> *~I cannot guarantee that all these are borked symlinks.~*
		> *~Also, filenames with spaces (if any) will not be handled correctly.~*
		? *~Proceed at your own risk.~*
		FILES="$FILES" =~ s/\n/ /gr
		= unget $FILES
	---
</CustomCommand>

<CustomCommand push-some>
	Description = Push only X local commits to origin
	Verify = project
	Argument = how_many								<integer (number of commits to push)>

	action <<---
		%how_many  > %num_local_commits		->	! Don't have that many commits to push.
		%how_many == %num_local_commits		->	! That's all the commits there are to push; just run `%me push`.
		COMMITS_TO_KEEP=%num_local_commits - %how_many
		= sync
		>
		git show -s --oneline %local_commits | tail -n%how_many
		? The commits above will be pushed.
		git push origin HEAD~$COMMITS_TO_KEEP:%cur_branch
		COMMITS_PUSHED=join(', ', (reverse %local_commits)[0..(%how_many-1)])
		> *+Pushed the following commits to origin: $COMMITS_PUSHED+*
	---
</CustomCommand>

<CustomCommand commit-filedate>
	Description = Commit, but use the mtime of <file> as the commit date
	Verify = project
	Argument = file									<file to draw date from>

	action <<---
		%has_staged			->	? *~Some changes already staged!!~*
		not -r %file		->	! Can't read file %file.
		DATETIME=do { use Date::Easy; datetime((stat %file)[9])->iso8601 }
		git add -p %file
		git commit -v --date $DATETIME
	---
</CustomCommand>

<CustomCommand commit-date>
	Description = Commit, but use the supplied datetime as the commit date
	Verify = project
	Argument = date									<date string (flexible format)>

	action <<---
		not %has_staged		->	! Stage your changes first.
		DATETIME=do { use Date::Easy; datetime(%date)->iso8601 }
		not "$DATETIME"		->	! Can't interpret date.
		git commit -v --date $DATETIME
	---
</CustomCommand>


<CustomCommand previous-version>
	Description = Show the file prior to its last modification (to stdout)
	Verify = project
	Argument = file									<file to show previous version of>

	action <<---
		REVISION=do {my $r=`git log --pretty='%h' -n1 --follow ${\(%file)}`; chomp $r; $r}
		git show $REVISION^:%file
	---
</CustomCommand>


<CustomInfo remotes>
	Type = ArrayRef
	action <<---
		git remote
	---
</CustomInfo>
<CustomCommand set-upstream>
	Description = Set upstream remote for the current branch
	Verify = project
	Argument = remote								<name of remote (must exist)>

	action <<---
		#NUM_REMOTES=scalar @[(%remotes)]
		not %remote ~~ [%remotes]		->	! Remote %remote does not exist
		git fetch %remote
		git branch --set-upstream-to %remote/%cur_branch
	---
</CustomCommand>
