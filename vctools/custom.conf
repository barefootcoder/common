# THIS IS SHARED ACROSS ALL MACHINES

# personal overrides for VC commands
<git>
	<commands>
		stage <<---
			git add -p %files
		---
		unbranch <<---
			%cur_branch ne %Mainline	->	echo %cur_branch >%last_branch_file
			git checkout %Mainline
		---
	</commands>
</git>
# these really should be in the <git> block above
# but they don't work there, for some reason
	<CustomInfo last_branch_file>
		action <<---
			{ glob("~/.vctools/last_branch." . %project) }
		---
	</CustomInfo>
	<CustomCommand stat-plus>
		action <<---
			= stat
			git-helper-log -LNs | perl -0777 -e '$o = <STDIN> and print "\nUnpushed commits:\n$o\n"'
		---
	</CustomCommand>
	<CustomCommand rebranch>
		action <<---
			not -e %last_branch_file	->	! Don't know what last active branch was.
			git checkout `cat %last_branch_file`
		---
	</CustomCommand>


# This method for finding unpushed commits based on:
# http://stackoverflow.com/questions/2016901/viewing-unpushed-git-commits
#
# Unfortunately, limiting it to only the current branch turned out to be non-trivial. :-/
# You can give `--branches` an arg, but it either has to contain a wildcard, or it gets "/*"
# appended to it automatically, which makes it match nothing.  So we *have* to add the "*" at the
# end, at which point it matches.  Unfortunately, it would also match any other branch name that was
# the same as the current branch name, only longer.  For instance, if you were on branch
# feature/foo, this would match feature/foo, but also feature/foo-bar.  Which we don't want.  So we
# apply a bit of Perl magic at the end to make sure we only get the branch we're looking for.  Note
# that "%d" produces either "(feature/foo)" *or* "(HEAD -> feature/foo)"--or possibly even
# "(feature/foo, feature/bar)"--so that's why the regex is a bit more complex than you might
# imagine at first.
<CustomInfo local_commits>
	Type = ArrayRef
	action <<---
		# seems silly to shell out to `perl` when we're *running* in Perl
		# but, strangely, this code is actually simpler (and easier to follow)
		# this is partially because it relies on autosplit (-a) to do some work behind the scenes
		# but also because interpolating the %cur_branch is easier/cleaner this way
		# and, lastly, because it's easier to break into separate lines this way
		# code to do it all in Perl (not fully tested):
		#		{	my $in;
		#			join('',
		#				grep { $in = $2 eq %cur_branch if s{\s+\((.*? )?(\S+?)(,.*?)?\).*$}{}; $in }
		#				`git log --branches="${\(%cur_branch)}*" --not --remotes --pretty="%h %d"`
		#			)
		#		}
		# except you (currently) have to jam all that onto one line
		LOCAL_COMMITS_PROGLET='$i = m{\((.*? )?\Q' . %cur_branch .'\E(,.*?)?\)} if $F[1]; print $F[0] if $i'
		git log --branches="%cur_branch*" --not --remotes --pretty="%h %d" | perl -lane "$LOCAL_COMMITS_PROGLET"
	---
</CustomInfo>

<CustomInfo num_local_commits>
	Type = Str
	action <<---
		{ scalar %local_commits }
	---
</CustomInfo>


<CustomCommand merge>
    Verify = project
    Files = 0

    action <<---
		%cur_branch !~ m{^feature/} -> ! Will only merge trunk into a feature branch.
		%is_dirty -> git stash save -u 'Local changes in effect as of `%me merge`'
		git fetch origin
		git merge origin/%Mainline
		%is_dirty -> git stash pop
    ---
</CustomCommand>


<CustomCommand chktabs>
	Description = Verify there are no tabs in modified files
    Verify = project

	action <<---
		POLICY=$self->config->policy
		"$POLICY" eq "CE" ->	CHECKTABS=`checktabs -n`
		"$POLICY" eq "CE" ->	"$CHECKTABS" -> > $CHECKTABS
		"$POLICY" eq "CE" ->	"$CHECKTABS" -> ! "fix checktabs problems before continuing"
	---
</CustomCommand>

<CustomCommand stg-amend>
	Description = Amend a previous commit
    Verify = project
    Argument = how_far_back							<integer (number of commits to go back to) or SHA1>

    action <<---
		# verify state and set up proper value for $TARGET
		= chktabs
		length(%how_far_back) >= 7	->	TARGET=%how_far_back
		length(%how_far_back) < 7	->	%how_far_back == 1 -> ! Won't do most recent commit; use `%me commit -F` instead.
		length(%how_far_back) < 7	->	TARGET="HEAD" . '^' x (%how_far_back - 1)
		`git branch -r --contains $TARGET` -> ! Cannot amend; commit has already been published.
		!%is_dirty -> > *~You have no changes to apply.~*
		!%is_dirty -> ? Are you sure you want to amend anyway?

		# first, save all mods
		STASH_MESSAGE_OUTER="changes for stg-amend"
		git stash save -u "$STASH_MESSAGE_OUTER"

		# now fire up a rebase, then, *if* the user chooses to edit a commit,
		# re-apply the mods and let the user stage some of them
		git rebase -i $TARGET^
		COMMIT_EDIT=`git status` =~ /rebase in progress/ ? 1 : 0
		$COMMIT_EDIT	->		git stash apply	|| :
		$COMMIT_EDIT	->		= unstage
		$COMMIT_EDIT	->		git add -i

		# now adjust the commit (again, *if* the user chose to edit a commit)
		$COMMIT_EDIT	->		git commit -v --amend

		# now we really need to clear out all the leftover mods before proceeding
		# the easiest (and safest) way to do that is to just stash again, then drop the stash
		$COMMIT_EDIT	->		STASH_MESSAGE_INNER="throwing away unused changes"
		$COMMIT_EDIT	->		git stash save -u "$STASH_MESSAGE_INNER"
		# note safe stash drop
		$COMMIT_EDIT	->		git stash list | grep -q "$STASH_MESSAGE_INNER" && git stash drop ||:

		# now put back all the intervening commits, then restore any remaining mods
		$COMMIT_EDIT	->		git rebase --continue
		# again, safe stash drop
		git stash list | grep -q "$STASH_MESSAGE_OUTER" && git stash pop ||:
    ---
</CustomCommand>

<CustomCommand amend-local>
	Description = Amend one commit from among all local commits
    Verify = project

    action <<---
		= chktabs
		> *-%num_local_commits local commits-*
		= stg-amend %num_local_commits
    ---
</CustomCommand>

<CustomCommand stash-files>
	Description = Show files stored in a stash
	Verify = project
	<Trailing name>
		description = optional name ("stash@{1}") or number ("1") to identify stash
		singular = name
		qty = 0..1
	</Trailing>

	action <<---
		# make it so you can just go `vc stash-files 1`
		STASH=my $f = %name[0] // '0'; $f =~ /^\d+$/ ? sprintf('stash@{%s}', $f) : $f
		# don't forget: env expansion still takes place in single quotes
		# normally I would use double quotes just to make it more obvious, but $STASH contains an @,
		# so it will give a "Possible unintended interpolation" error if we don't use single quotes
		!system('git rev-list --quiet $STASH^3 2>/dev/null')		->	UNTRACKED='$STASH^3'
		git show $STASH $UNTRACKED --stat | grep '^ [^ ]'
	---
</CustomCommand>

<CustomCommand unstash-force>
	Description = Unstash dammit
	Verify = project
	<Trailing name>
		description = optional name ("stash@{1}") or number ("1") to identify stash
		singular = name
		qty = 0..1
	</Trailing>

	action <<---
		# make it so you can just go `vc unstash-force 1`
		STASH=my $f = %name[0] // '0'; $f =~ /^\d+$/ ? sprintf('stash@{%s}', $f) : $f
		git stash show --no-color -p $STASH | git apply
		git stash drop $STASH
	---
</CustomCommand>

<CustomCommand clean>
	Description = Remove local changes in a recoverable fashion
	Verify = project

	action <<---
		!%is_dirty	->	! Nothing to clean!
		? *~Local changes will be lost!~* (but recoverable via SHA1 of dropped stash)
		git reset HEAD || :
		git stash save -u 'Local changes in effect as of `%me clean`'
		git stash drop
	---
</CustomCommand>

<CustomCommand push-some>
	Description = Push only X local commits to origin
    Verify = project
    Argument = how_many								<integer (number of commits to push)>

    action <<---
		%how_many  > %num_local_commits		->	! Don't have that many commits to push.
		%how_many == %num_local_commits		->	! That's all the commits there are to push; just run `%me push`.
		COMMITS_TO_KEEP=%num_local_commits - %how_many
		= sync
		>
		git show -s --oneline %local_commits | tail -n%how_many
		? The commits above will be pushed.
		git push origin HEAD~$COMMITS_TO_KEEP:%cur_branch
		COMMITS_PUSHED=join(', ', (reverse %local_commits)[0..(%how_many-1)])
		> *+Pushed the following commits to origin: $COMMITS_PUSHED+*
    ---
</CustomCommand>

<CustomCommand commit-filedate>
	Description = Commit, but use the mtime of <file> as the commit date
    Verify = project
    Argument = file									<file to draw date from>

    action <<---
		%has_staged			->	? *~Some changes already staged!!~*
		not -r %file		->	! Can't read file %file.
		DATETIME=do { use Date::Easy; datetime((stat %file)[9])->iso8601 }
		git add -p %file
		git commit -v --date $DATETIME
    ---
</CustomCommand>

<CustomCommand commit-date>
	Description = Commit, but use the supplied datetime as the commit date
    Verify = project
    Argument = date									<date string (flexible format)>

    action <<---
		not %has_staged		->	! Stage your changes first.
		DATETIME=do { use Date::Easy; datetime(%date)->iso8601 }
		not "$DATETIME"		->	! Can't interpret date.
		git commit -v --date $DATETIME
    ---
</CustomCommand>

<CustomInfo remotes>
	Type = ArrayRef
	action <<---
		git remote
	---
</CustomInfo>
<CustomCommand set-upstream>
	Description = Set upstream remote for the current branch
	Verify = project
    Argument = remote								<name of remote (must exist)>

	action <<---
		#NUM_REMOTES=scalar @[(%remotes)]
		not %remote ~~ [%remotes]		->	! Remote %remote does not exist
		git fetch %remote
		git branch --set-upstream-to %remote/%cur_branch
	---
</CustomCommand>
