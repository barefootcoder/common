#! /usr/bin/env perl

use myperl DEBUG => 1;
use autodie qw< :all >;

use IO::Prompt;
use Tie::IxHash;
use Term::ANSIScreen;
use File::Glob qw< :glob >;
use Config::General qw< ParseConfig >;


const our $MANAGERS =>
{
	diane	=>	'Diane Xu',
	aran	=>	'Aran Deltac',
	mike	=>	'Mike Rozek',
};

const our $HIRING_EMAILS =>
{
	'Diane Xu'				=>	'dxu@rent.com',
	'Aran Deltac' 			=>	'adeltac@rent.com',
	'Mike Rozek'			=>	'mrozek@rent.com',
};

const our $NON_RECRUITERS => { map { $_ => 1 } qw< jobs.perl.org Dice.com > };

const our $CONF_DIR => file($0)->dir->resolve->parent->subdir('conf', 'hire');
const our $CONFIG => read_config();

sub read_config
{
	my $filename = 'hire.conf';
	my $homedir = dir($ENV{HOME});
	my $conf_file = -e $homedir->file($filename) ? $homedir->file($filename) : $CONF_DIR->file($filename);
	return { ParseConfig($conf_file) };
}



######################################################################
#         Resume
######################################################################

class Resume
{
	use myperl::Google;


	has doc		=>	( ro, isa => 'Net::Google::DocumentsList::Item', required );
	has perms	=>	( ro, isa => HashRef, lazy, builder => '_retrieve_acls' );

	around BUILDARGS ($class: @_)
	{
		if (@_ == 1)
		{
			given (ref $_[0])
			{
				# single argument is a document; simple enough
				return $class->$orig( doc => $_[0] ) when 'Net::Google::DocumentsList::Item';

				when ('')
				{
					# single argument is a scalar: assume it's an URL string
					my ($url) = @_;

					# we need to get the resource ID out of the URL
					$url =~ m{https?://docs\.google\.com} or die("not a Google Docs URL");
					$url =~ s{ /edit $ }{}x;
					$url =~ s{ ^ .* / }{}x;								# purposefully greedy

					my $doc;
					foreach (qw< document pdf >)						# could be a document or a pdf; try 'em both
					{
						my $resource_id = "$_:$url";
						debuggit(3 => "trying to create document with resource ID", $resource_id);
						$doc = $GOOGLE->document({ resource_id => $resource_id });
						last if $doc;
					}
					die("can't find document with key $url") unless $doc;

					return $class->$orig( doc => $doc );
				}
			}
		}
		return $class->$orig( @_ );
	}

	method _retrieve_acls
	{
		my $perms = {};

		foreach ($self->doc->acls)
		{
			my $scope_type = $_->scope->{'type'};
			if ($scope_type eq 'user')
			{
				$perms->{$_->scope->{'value'}} = $_->role;
			}
			else
			{
				die("don't know how to deal with scope type $scope_type");
			}
		}

		return $perms;
	}


	method upload ($class: $file)
	{
		print STDERR "uploading ... ";
		my $doc = $class->new( $GOOGLE->upload_doc($file, "Candidate Resumes") );
		say STDERR "done\n";
		return $doc;
	}


	method url
	{
		return $self->doc->alternate;
	}

	method dump
	{
		tie my %info, 'Tie::IxHash',
		(
			url			=>	$self->doc->alternate,
		);

		my $len = max map { length } keys %info;
		my $fmt = "{<{$len}<} : {<{120}<}";
		print foreach map { form($fmt, $_, $info{$_}) } keys %info;

		$len = max map { length } keys %{ $self->perms };
		$fmt = "    {<{$len}<} => {<<<<<<}";
		print foreach map { form($fmt, $_, $self->perms->{$_}) } keys %{ $self->perms };
	}


	method share ($email)
	{
		unless (exists $self->perms->{$email})
		{
			my $role = 'reader';										# no one needs to edit resumes
			$self->doc->add_acl({ role => $role, scope => { type => 'user', value => $email },
					'send-notification-emails' => 'false' });			# no need to send out emails every time
			$self->perms->{$email} = $role;
		}
	}

}


######################################################################
#         Candidate
######################################################################

class Candidate
{
	use Module::Runtime;
	# can't use `use` here, because then $CONF_DIR would have to be defined at compile time, which
	# it isn't
	require myperl::Template; myperl::Template->import($CONF_DIR);

	use MooseX::ClassAttribute;


	our %IN_HOUSE_RECRUITER =
	(
	);

	our %DISPLAY_POSITIONS =
	(
		'Perl Engineer'		=>	'Sr Perl Engineer',
		'Client Ops'		=>	'Client Ops Engineer',
		'Release Mgr'		=>	'Release Manager',
	);

	class_has recruiters	=>	( ro, isa => 'Google::Worksheet', lazy, default => method {
																						Google::Worksheet->new(
																								doc => "candidates",
																								name => "Recruiters",
																								key => "Name"
																						);
																					}, );

	method get_recruiter ($class: $recruiter)
	{
		try
		{
			return $class->recruiters->get_row($recruiter);
		}
		catch ($err where { /no such row as/ } )
		{
			return undef;
		}
	}


	has data		=>	( ro, isa => 'ArrayRef[Maybe[Net::Google::Spreadsheets::Cell]]', required );
	has sheet		=>	( ro, isa => 'HiringSheet', required, weak_ref );

	has id			=>	( ro, isa => Str, lazy, default => method { $self->get_datum('id') } );
	has first		=>	( ro, isa => Str, lazy, default => method { $self->get_datum('firstName') } );
	has last		=>	( ro, isa => Str, lazy, default => method { $self->get_datum('lastName') });
	has status		=>	( ro, isa => Str, lazy, default => method { $self->get_datum('Status') });
	has source		=>	( ro, isa => Str, lazy, default => method { $self->get_datum('Source') });
	has phone		=>	( ro, isa => Str, lazy, default => method { $self->get_datum('phone') });
	has resume_url	=>	( ro, isa => Maybe[Str], lazy, default => method { $self->get_datum('resume link') });
	has resume		=>	( ro, isa => 'Maybe[Resume]', lazy, builder => '_resume_doc');

	method _resume_doc
	{
		my $url = $self->resume_url;
		if ($url)
		{
			my $resume;
			try
			{
				$resume = Resume->new($url);
			}
			catch ($err where { /not a Google Docs URL/ || /can't find document with key/ })
			{
				return undef;
			}
			return $resume;
		}

		return undef;
	}


	method hr_email ($class: )
	{
		return join(',', map { qq{"$_" <$IN_HOUSE_RECRUITER{$_}>} } keys %IN_HOUSE_RECRUITER);
	}


	method row
	{
		return $self->data->[1]->row;
	}

	method get_datum (Str $type)
	{
		my $col = $self->sheet->header_col($type);
		my $cell = $self->data->[$col];
		return $cell ? $cell->content : undef;
	}

	method set_datum (Str $type, Str $value)
	{
		my $col = $self->sheet->header_col($type) || die("no such column $type");
		my @c = $self->sheet->eng->batchupdate_cell({ row => $self->row, col => $col, input_value => $value });
		$self->data->[$col] = $c[0];
	}

	method templatize ($file, Maybe[HashRef] $hash = {})
	{
		use Text::Tabs; $tabstop = 4;

		$hash->{$_} = $self->get_datum($_) foreach $self->sheet->headers;
		$hash->{name} = $self->name;
		$hash->{display_position} = $DISPLAY_POSITIONS{$self->get_datum('position')};

		$hash->{HR}->{email} = CLASS->hr_email;

		my $recruiter = $self->get_recruiter($self->source);
		if ($recruiter)
		{
			# have to flatten this or TT won't play nice
			$hash->{Recruiter} = {};
			$hash->{Recruiter}->{$_} = $recruiter->{$_} foreach keys %$recruiter;
		}

		$hash->{Config} = $CONFIG;

		return join('', expand(templ::process($file, $hash)));
	}

	method name
	{
		return join(' ', $self->first, $self->last);
	}

	method dump
	{
		my $len = max map { length } $self->sheet->headers;
		my $fmt = "{<{$len}<} : {<{80}<}";
		print foreach map { my $d = $self->get_datum($_); $d ? form($fmt, $_, $d) : () } $self->sheet->headers;
	}

}


######################################################################
#         HiringSheet
######################################################################

class HiringSheet
{
	use myperl::Google;

	use Date::Format;
	use Net::Google::Spreadsheets;


	our %STATUSES =
	(
		'Rejected'				=>	'previous round',
		'Completed'				=>	'previous round',
		'Resume Received'		=>	'in pipeline',
		'Resume Reviewed'		=>	'in pipeline',
		'Awaiting Phone Screen'	=>	'in pipeline',
		'Phone Screened'		=>	'in pipeline',
		'Test Sent'				=>	'in pipeline',
		'Test Received'			=>	'in pipeline',
		'Awaiting Scheduling'	=>	'in pipeline',
		'Awaiting Interview'	=>	'in pipeline',
		'Interviewed'			=>	'in pipeline',
		'Offer Underway'		=>	'in pipeline',
		'Hired'					=>	'out of pipeline',
		'On Standby'			=>	'on hold',
		'Refused'				=>	'out of pipeline',
		'Pass'					=>	'out of pipeline',
	);


	has _sheet			=>	( ro, isa => 'Net::Google::Spreadsheets::Spreadsheet', lazy, builder => '_get_sheet' );
	has _headers		=>	( rw, isa => 'ArrayRef[Net::Google::Spreadsheets::Cell]', lazy, builder => '_get_headers' );
	has _data			=>	( rw, isa => 'ArrayRef[Candidate]', lazy, builder => '_get_data', predicate => '_has_data' );
	has _old_data		=>	( rw, isa => 'HashRef', lazy, default => sub { {} } );
	has _blanks			=>	( rw, isa => ArrayRef, lazy, default => sub { [] } );

	has eng				=>	( ro, isa => 'Net::Google::Spreadsheets::Worksheet', lazy, builder => '_get_eng' );


	method _get_sheet
	{
		return $GOOGLE->spreadsheet({ title => 'candidates' });
	}

	method _get_eng
	{
		return $self->_sheet->worksheet({ title => 'Eng' });
	}

	method _get_headers
	{
		return [ $self->eng->cells({ 'min-row' => 1, 'max-row' => 1 }) ];
	}

	method _get_data
	{
		print STDERR "refreshing ... ";

		my %rows;
		my %blanks;
		foreach ( $self->eng->cells({ 'min-row' => $self->num_header_rows + 1 }) )
		{
			my ($row, $col) = ($_->row, $_->col);
			if ($col == 1 and $_->content eq '')
			{
				# blank row
				$blanks{$row} = 1;
			}
			elsif ($col != 1 and exists $blanks{$row})
			{
				unless ($_->content eq '')								# doesn't matter if it's just blank
				{
					# this should never really happen
					# maybe if someone is right in the middle of entering data into a row
					die("inconsistent data detected on row $row in column " . chr(ord('A') + $col -1));
				}
			}
			else
			{
				# candidate data
				$rows{$_->row}->[$_->col] = $_;
			}
		}

		@{ $self->_blanks } = sort { $a <=> $b } keys %blanks;

		my $data = [];
		foreach (sort { $a <=> $b } keys %rows)
		{
			my $status = $rows{$_}->[1]->content;
			debuggit(4 => "status is", $status);
			if ( $STATUSES{ $status } eq 'previous round' )
			{
				my @cells = map { defined() ? $_->content : undef } @{$rows{$_}};
				$cells[0] = $_;
				my $name = lc join(' ', @cells[3,4]);
				$self->_old_data->{$name} = [ @cells ];
				debuggit(4 => "set old datarow for", $name, "for status", $status);
			}
			else
			{
				push @$data, Candidate->new( data => $rows{$_}, sheet => $self );
			}
		}

		debuggit(2 => "created", scalar @$data, "candidates, max row", $data->[-1]->row);
		debuggit(2 => "created", scalar @{$self->_blanks}, "blank rows, from",
				$self->_blanks->[0], "to", $self->_blanks->[-1]);
		debuggit(6 => "created old data hash:", DUMP => $self->_old_data);
		say STDERR "done\n";
		return $data;
	}

	method _read_candidate (Int $row)
	{
		my $cells = [];
		$cells->[$_->col] = $_ foreach $self->eng->cells({ row => $row });
		return Candidate->new( data => $cells, sheet => $self );
	}

	method _get_single_candidate (Int $row)
	{
		print STDERR "reading back ... ";
		push @{ $self->_data }, $self->_read_candidate($row);
		say STDERR "done\n";
	}


	method num_header_rows ()
	{
		return 2;
	}


	method headers ()
	{
		return map { $_->content } @{ $self->_headers };
	}

	method header_col (Str $name)
	{
		foreach (@{ $self->_headers })
		{
			return $_->col if $_->content eq $name;
		}
		die("header $name doesn't appear to exist");
	}


	method refresh ()
	{
		$self->_headers($self->_get_headers);
		$self->_data($self->_get_data);
	}


	method data_column (Int $col)
	{
		$self->eng->cells({ 'min-row' => $self->num_header_rows + 1, 'min-col' => $col, 'max-col' => $col });
	}


	method get_next_seq ($id_base)
	{
		my $max_seq = 0;
		foreach (@{ $self->_data })
		{
			my ($base, $seq) = split('-', $_->id);
			$max_seq = max($max_seq, $seq) if $id_base eq $base;
		}
		return join('-', $id_base, $max_seq + 1);
	}

	method all_sources ()
	{
		return uniq map { $_->source } @{ $self->_data };
	}

	method list_candidates
	{
		say $_->id, ' ', $_->name, '  (', $_->status, ')' foreach @{ $self->_data };
	}

	method find_candidate ($first, $last)
	{
		$first = lc $first;
		$last = lc $last;
		$self->_data;													# have to trigger building of _data and _old_data
		debuggit(2 => "searching for", $first, $last, "in", scalar keys %{$self->_old_data}, "rows of old data");

		if (my $old = $self->_old_data->{"$first $last"})
		{
			return $old;
		}

		foreach (@{ $self->_data })
		{
			debuggit(4 => "checking row", $_->row);
			if (lc $_->first eq $first and lc $_->last eq $last)
			{
				$_ = $self->_read_candidate($_->row);
				return $_;
			}
		}

		return undef;
	}

	method add_candidate (HashRef $data)
	{
		# fill in a few defaults
		$data->{'date received'} = time2str('%m/%d/%Y', time);
		$data->{'id'} = $self->get_next_seq(time2str('%Y%m%d', time));

		# determine which row to use
		my $row;
		LOOP:
		{
			$row = shift @{ $self->_blanks };
			if ( grep { $_->content } $self->eng->cell({ row => $row,
					'min-col' => $self->header_col('firstName'), 'max-col' => $self->header_col('lastName') }) )
			{
				$self->refresh;
				redo LOOP;
			}
		}

		# now fill 'er up
		debuggit("going to write to row", $row);
		my @cells;
		foreach (keys %$data)
		{
			next unless defined $data->{$_};
			push @cells, { row => $row, col => $self->header_col($_), input_value => $data->{$_} };
		}
		$self->eng->batchupdate_cell(@cells);

		# and read 'er back
		$self->_get_single_candidate($row);
	}

	method current_candidates
	{
		return grep { my $st = $_->status; die("unknown status $st") unless exists $STATUSES{$st}; $STATUSES{$st} eq 'in pipeline' or $STATUSES{$st} eq 'on hold' } @{ $self->_data };
	}

}


######################################################################
#         main()
######################################################################


our $screen = Term::ANSIScreen->new;
our $sheet = HiringSheet->new;


tie my %email_menu, 'Tie::IxHash',
(
	'Foreign Telecommuter'			=>	func { candidate_email('foreign-contractor.tt') },
	'First Day Email'				=>	\&first_day,
	'Back to Main'					=>	undef,
);

tie my %resume_menu, 'Tie::IxHash',
(
	'Upload Resume for Candidate'	=>	\&upload_resume_for_candidate,
	'Browse Resume for Candidate'	=>	\&dump_resume,
	'Share Out Current Resumes'		=>	\&share_resumes,
	'Back to Main'					=>	undef,
);

tie my %main_menu, 'Tie::IxHash',
(
	'Enter New Candidate'			=>	\&get_new_candidate,
	'Set up Phone Screen'			=>	\&phone_screen_setup,
	'Confirm Phone Screen'			=>	\&phone_screen_confirmation,
	'Print Phone Screen Notes'		=>	func { system("lpr $ENV{HOME}/proj/rent/doc/howto/interview-programmer/phone.txt") },
	'Send Candidate Take-Home Test'	=>	\&send_take_home_test,
	'Score Take-Home Test'			=>	\&take_home_test,
	'Set Lunch Interview'			=>	\&lunch_interview,
	'Print New Hire Info'			=>	\&new_hire_info,
	'List Candidates'				=>	func { $sheet->list_candidates },
	'Browse Candidate'				=>	\&dump_candidate,
	'Send Emails'					=>	\%email_menu,
	'Resume Stuff'					=>	\%resume_menu,
	'Refresh Data'					=>	func { $sheet->refresh },
	Reload							=>	\&reload_program,
	'Show Config'					=>	\&show_config,
	Quit							=>	func { exit },
);

menu(\%main_menu);


######################################################################
#         functions
######################################################################

func menu ($menu)
{
	state $menu_prompt = "Enter letter of choice.\nUse <Esc> to return to previous menu.\n";
	MENULOOP: while (1)
	{
		system("clear");
		say "\nYou are logged in as $CONFIG->{'name'}.  Choose 'Reload' to change that.\n\n";

		while (1)
		{
			local $_ = prompt $menu_prompt, -menu => [ keys %$menu ];
			given ($menu->{$_})
			{
				dispatch($_) when ref eq 'CODE';
				menu($_) and next MENULOOP when ref eq 'HASH';
				return 1 when undef;
			}
			last if $_;
		}

		print "\n\nPress RETURN to continue ...  ";
		<STDIN>;
	}
}

func dispatch ($code)
{
	say "\n";
	try
	{
		$code->();
		1;
	}
	catch ($err)
	{
		say STDERR "call died with: $err";
	}
}


func prompt_for_candidate
{
	my $name = prompt "Candidate name: ";
	say '';
	return map { s/_(.)/ \u$1/g; ucfirst } split(' ', $name);
}

func existing_candidate
{
	my ($first, $last) = prompt_for_candidate;
	return $sheet->find_candidate($first, $last) || die("Can't find candidate $first $last");
}

func dump_candidate
{
	my $cand = existing_candidate();
	$cand->dump;
	if (prompt -yd => 'n', "Show resume? ")
	{
		system('firefox', $cand->resume_url);
	}
}

func get_new_candidate
{
	my ($first, $last) = prompt_for_candidate;

	debuggit(2 => "first:", $first, "last:", $last);
	if (my $cand = $sheet->find_candidate($first, $last))
	{
		if (ref $cand eq 'ARRAY')
		{
			say "WARNING! candidate found on row ", $cand->[0];
			say "data: ", join(';', map { defined() ? $_ : () } @$cand[1..8,15,18,21,25]);
		}
		else
		{
			say "WARNING! candidate found on row ", $cand->row;
		}
	}
	else
	{
		my $source = prompt -menu => [ $sheet->all_sources ];
		my $resume = upload_resume();

		$sheet->add_candidate({
			firstName		=>	$first,
			lastName		=>	$last,
			Source			=>	"$source",								# have to stringify this to remove Damian magic
			screener		=>	$CONFIG->{'initials'},
			position		=>	'Perl Engineer',
			'job type'		=>	'Any',
			'resume link'	=>	$resume ? $resume->url : undef,
		});
	}

}


func take_home_test
{
	use autodie qw< system >;

	my $pwd = dir()->absolute;
	chdir $CONFIG->{take_home_test_dir};;

	try
	{
		#my $cand = existing_candidate();
		#my $name = $cand->name;
		my ($first, $last) = prompt_for_candidate;
		my $name = "$first $last";

		warn("going to do a review of $name in dir ", dir()->absolute);
		system("./review" => $name);
		foreach (bsd_glob("$name/*"))
		{
			chdir $_ if -d;
		}
		system("/bin/tcsh");
	}
	catch ($err)
	{
		chdir $pwd;
		die($err);
	}
	chdir $pwd;
}


func lunch_interview
{
	use myperl::Google;

	use Date::Format;
	use Time::ParseDate;

	state $ATTENDEES =
	{
		'Alain Avakian'			=>	'aavakian@rent.com',
		'Benny Millares'		=>	'bmillares@rent.com',
		# all the people on the hiring team get included
		%$HIRING_EMAILS,
		# in-house recruiter (if there is one) should be included just so s/he knows about it
		%Candidate::IN_HOUSE_RECRUITER,
	};
	state $meeting_descr = "Standard lunch and then conference room testing (if someone could reserve Spaceballs "
			. "for at least 1-3, that would be appreciated).  I've marked the event as going until 4 just in case "
			. "we run over (we often do).";

	state $CLIOPS_BUSINESS =
	{
		'Monica Harang'		=>	'mharang@ebay.com',
		'Gail Wu'			=>	'gaiwu@ebay.com',
		'Justin Monday'		=>	'jmunday@rent.com',
		'Robert Johnson'	=>	'rojohnson@rent.com',
	};
	state $cliops_meeting_descr = "Business portion of the interview for Client Ops candidates.";

	my $cand = existing_candidate();

	my $datetime = prompt("Enter date: ");
	my $secs = parsedate("$datetime noon", PREFER_FUTURE => 1) || die("couldn't parse your date/time");

	$GOOGLE->add_cal_event(
		title		=>	"Lunch Interview: " . $cand->name,
		location	=>	"Cafe Bizou or Tiato or Daily Grill / Spaceballs (hopefully)",
		content		=>	$meeting_descr,
		when		=>	"$datetime noon",
		howlong		=>	4,
		guests		=>	$ATTENDEES,
		reminder	=>	"sms 3h",
	);
	$cand->set_datum( "interview date" => time2str('%m/%d/%Y', $secs) );

	if ($cand->get_datum("position") eq "Client Ops")
	{
		my $confroom = prompt("Enter conference room: ");
		$GOOGLE->add_cal_event(
			title		=>	"Client Ops Interview: " . $cand->name,
			location	=>	$confroom,
			content		=>	$cliops_meeting_descr,
			when		=>	"$datetime 3:30pm",
			howlong		=>	.5,
			guests		=>	$CLIOPS_BUSINESS,
			reminder	=>	"sms 3h",
		);
	}
}


func new_hire_info
{
	my $cand = existing_candidate();
	say "\n";

	my $manager = prompt "Hiring Manager: ", -menu => [ values %$MANAGERS ];
	my $agency = $cand->get_datum("Source");
	$agency = '' if exists $NON_RECRUITERS->{$agency};

	say "\n";
	my $fmt = '{<<<<<<<<<<<<<<<<<<<<<<<} : {<<<<<<<<<<<<<<<<<<<<<<<<<<<<}';
	print form $fmt, 'Employee Full Name', $cand->name;
	print form $fmt, 'Employee Phone Number', $cand->phone;
	print form $fmt, 'Employee Personal Email', $cand->get_datum("email");
	print form $fmt, 'Employee Type', $cand->get_datum("contractor status");
	print form $fmt, 'Manager', $manager;
	print form $fmt, 'Agency if Contractor', $agency;
	print form $fmt, 'Start Date', $cand->get_datum("start date");
}


func candidate_email ($file, HashRef $extra_vars?)
{
	my $cand = existing_candidate();
	say "\n";
	print $cand->templatize($file, $extra_vars);

	return $cand;														# in case our caller wants it
}

func phone_screen_setup
{
	my $cand = candidate_email('phone-screen-set.tt');
	$cand->set_datum( "ps request date" => time2str('%m/%d/%Y', time) );
}

func phone_screen_confirmation
{
	use myperl::Google;

	use Date::Format;
	use Time::ParseDate;

	my $cand = existing_candidate();
	my $phone;
	unless ($phone = $cand->phone)
	{
		$phone = prompt("Enter phone number: ");
		die("have to have phone number") unless $phone;
		$cand->set_datum( phone => "$phone" );							# remove Damian magic again
	}

	my $datetime = prompt("Enter date and time: ");
	my $secs = parsedate($datetime) || die("couldn't parse your date/time");

	$GOOGLE->add_cal_event(
		title		=>	"Phone Screen: " . $cand->name,
		location	=>	$phone,
		when		=>	$datetime,
		howlong		=>	1,
		guests		=>	{ $CONFIG->{'name'} => $HIRING_EMAILS->{$CONFIG->{'name'}} },
	);
	$cand->set_datum( "ps 1 date" => time2str('%m/%d/%Y', $secs) );

	$datetime = time2str('on %L/%d at %l:%M%P %Z', $secs);
	$datetime =~ s/\s(\s\d)/$1/;
	$datetime =~ s/(\d):00/$1/;
	$datetime =~ s{/0(\d)}{/$1};
	say "\n";
	print $cand->templatize('phone-screen-conf.tt', { datetime => $datetime });
}

func first_day
{
	my $cand = existing_candidate();
	my $manager = prompt "Hiring Manager: ", -menu => [ values %$MANAGERS ];

	say "\n";
	print $cand->templatize("first-day.tt", { manager => $manager });
}

func send_take_home_test
{
	my $cand = candidate_email('take-home.tt');
	$cand->set_datum( "test sent date" => time2str('%m/%d/%Y', time) );
}


func upload_resume
{
	my @pdfs = glob("$CONFIG->{'pdf_files_dir'}/*.pdf");
	die("too many PDF files in your $CONFIG->{'pdf_files_dir'}; clean some out and try again") if @pdfs > 26;
	if (not @pdfs)
	{
		warn("no resumes found! proceeding without it ...");
		return;
	}

	my $file = prompt -menu => [ @pdfs ];
	return unless $file;

	my $resume = Resume->upload( $file );
	say "resource ID: ", $resume->doc->resource_id;
	say "URL? ", $resume->doc->alternate;

	return $resume;
}

func upload_resume_for_candidate
{
	my $cand = existing_candidate();
	my $resume = upload_resume();
	$cand->set_datum( 'resume link' => $resume->url );
}

func dump_resume
{
	my $cand = existing_candidate();
	my $resume = $cand->resume;
	unless ($resume)
	{
		say "resume URL not valid for a Google Doc";
		return;
	}

	$resume->dump;
	$resume->share('ninjaperrin@gmail.com');
	say '';
	if (prompt -yd => 'n', "Show resume? ")
	{
		system('firefox', $cand->resume_url);
	}
}

func share_resumes
{
	my $email = prompt("Enter email address to share all current resumes: ");
	say "Only resumes currently in the pipeline will be shared.";
	say "If the resume is currently shared to $email, it will not be reshared.";

	say '';
	local $| = 1;
	foreach ($sheet->current_candidates)
	{
		my $resume = $_->resume;
		if ($resume)
		{
			print $_->name, ' ... ';
			$resume->share($email);
			say 'done';
		}
	}
}


func reload_program
{
	my $prog = file($0);
	my $setup_prog = $prog->dir->file("setup_hire");
	$prog = $setup_prog if -x $setup_prog;
	exec $prog, @ARGV;
}

func show_config
{
	my $len = max map { length } keys %$CONFIG;
	my $fmt = "{<{$len}<} : {<{80}<}";
	print foreach map { form($fmt, $_, $CONFIG->{$_}) } keys %$CONFIG;

	print "\n", form($fmt, 'CONFIG DIR', $CONF_DIR);
}
