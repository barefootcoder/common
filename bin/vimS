#! /bin/bash

. ~/bin/bash_funcs

# restore a vim session, only *exactly* like it was before
#
# Normally, using `vim -S sessionfile` leaves buffer #1 empty, and starts loading files at buffer
# #2.  When searching for solutions for this online, most people advised that you shouldn't really
# care (or rely on) which files were set to which buffers.  However, I find that, after working with
# a certain set of files for a long time, your fingers grow accustomed to Ctrl-^ 3 being a certain
# file, and when the buffers get renumbered, you have to retrain your fingers.  Why kill your
# productivity this way?
#
# Plus the problem is very simple to fix.  When you do `vim -S sessionfile`, the first thing vim is
# doing (apparently) is loading an empty buffer (exactly as if you'd done just `vim`).  Then, as it
# goes through the `badd` commands in the sessionfile, it starts opening files, with the first one
# starting at buffer #2.  There is also an `args` command in the sessionfile, which contains the
# very first file (i.e., the one you initiated the whole session with by typing `vim first_file` in
# the first place), but this doesn't seem to help fix the buffer numbering problem.  (Alert readers
# of their sessionfiles will note that the `args` tends to come _after_ all the `badd`s; however,
# moving the `args` up ahead of all the `badd`s doesn't change anything.)
#
# So the solution is to simply use `vim -S sessionfile first_file` instead.  Of course, this
# requires that you remember which file was first.  You probably do, of course: if your fingers
# weren't trained to know which file was Ctrl-^ 1, you wouldn't be so desperate to get the damn
# numbering right in the first place.  However, it might be a long pathname, and who wants to type
# that every time?  But, of course, we've already mentioned that filename is right there, in the
# sessionfile, under the `args` command ...
#
# Other tricky bits:
#	*	vim will change to the directory specified in the "cd" line of the session file.  However,
#		if the "args" file is a relative path, that's too late for the first buffer.  So we should
#		pull out the "cd" line and go there first.
#	*	Environment variables in "badd" lines are okay; vim will expand them.  But in the "args"
#		line, we'll have to expand that ourselves.  Also, there might be tildes which need expanding
#		(this applies to the "cd" line as well).  Thus the `eval`s below.
#	*	Newer versions of `vim` use `argadd` instead of `args`.  So we search for either.

for prefix in ~/.vimS- ~/vimS/ ~/local/data/vimS/ ~/proj/vimS/ ./vimS/
do
	prefixes="$prefixes $prefix"
done

grepargs=-lP
while getopts ":lg:venh" opt
do
	case $opt in
		l)	list=yes
			;;
		g)	pattern="^badd .*$OPTARG"
			;;
		v)	verbose=yes
			grepargs=-hP
			;;
		e)	edit=yes
			;;
		n)	local=yes
			;;
		h)  echo "usage: $me -h | -l[v] | -[v]g <pattern> | -e <file> | [-n] <file>" >&2
			echo "    -l : list all possible session files" >&2
			echo "    -g : list possible session files which load a file matching <pattern> (Perl regex)" >&2
			echo "    -v : with -l, display full pathnames of session files; with -g, diplay full matching lines" >&2
			echo "    -e : instead of starting a vim session, edit the session file itself" >&2
			echo "         (with -l, edit all known vimS session files)" >&2
			echo "         (with -g, edit all matching vimS session files)" >&2
			echo "    -n : do not autosave the session (default: autosave any changes/new files)" >&2
			echo "    -h : this help message" >&2
			echo "    file : session file (or partial name)" >&2
			exit
			;;
		:)  usage_erorr "$OPTARG requires an argument"
			;;
		\?) usage_error "unknown argument $OPTARG"
			;;
	esac
done
shift $(( $OPTIND - 1 ))

if [[ $list || $pattern ]]
then
	[[ $list && $verbose ]] && echo "Name                 Aux?   Path"
	[[ $list && $verbose ]] && echo "============================================================================="

	function print_file
	{
		local base="$1"
		local file="$2"
		local aux

		if [[ ${file%%.(marks|funcs)} != $file && -e ${file%%.(marks|funcs)} ]]
		then
			continue
		fi

		if [[ $verbose ]]
		then
			[[ -r $file.funcs ]] && aux="${aux}F"
			[[ -r $file.marks ]] && aux="${aux}M"
			: ${aux:=.}
			printf "%-20s  %-2s    %s\n" $base $aux $file
		else
			echo $base
		fi
	}

	function handle_file
	{
		local base="$1"
		local file="$2"

		if [[ $pattern ]]
		then
			if ! grep $grepargs -q "$pattern" "$file"
			then
				return
			fi
		fi

		if [[ $edit ]]
		then
			edit_files="$edit_files $file"
		elif [[ $pattern ]]
		then
			if [[ $verbose ]]
			then
				grep $grepargs "$pattern" "$file" | sed "s/^/$base:/"
			else
				echo $base
			fi
		else
			print_file $base $file
		fi
	}

	for file in ./*.vimS
	do
		if [[ $file != *"*"* ]]
		then
			handle_file "$(basename $file .vimS)" "$file"
		fi
	done
	for prefix in $prefixes
	do
		for file in $prefix*
		do
			if [[ $file != *"*" ]]
			then
				handle_file "${file##$prefix}" "$file"
			fi
		done
	done
	[[ $edit ]] && vi $edit_files
	exit
fi

[[ -n $1 ]] || usage_error "sessionfile arg required"


sessionfile=$1
if [[ ! -f $sessionfile ]]
then
	sessionfile=$1.vimS
fi
if [[ ! -f $sessionfile ]]
then
	for prefix in $prefixes
	do
		[[ -f $sessionfile ]] && break
		sessionfile=$prefix$1
	done
fi

if [[ ! -f $sessionfile ]]
then
	die "session file $1 not specified, doesn't exist, or is unreadable"
fi

if [[ $edit ]]
then
	vi +/badd $sessionfile
	exit
fi

if [[ $local ]]
then
	tmpfile=/tmp/vimS.$$
	trap "/bin/rm -f $tmpfile" EXIT
	/bin/cp $sessionfile $tmpfile
	sessionfile=$tmpfile
fi

eval $(awk '$1 == "cd"' $sessionfile)
eval vim -S $sessionfile -c '"call LoadSessionAuxFiles()"' $(awk '$1 == "args" || $1 == "argadd" { print $2 }' $sessionfile)
