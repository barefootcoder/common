#! /usr/bin/env perl

use myperl::Script;

use Time::ParseDate qw<parsedate>;
use List::Util qw< minstr maxstr >;

const my $AVAIL => ':AVAILABILITY';


opts <<'-';
	[-av] [-w <num>] <command> <cmd_arg> file [...]
	-a : operate on all weeks (default: only the latest/first one found)
	-v : be more verbose (currently only works with `review' command)
	-w : operate on <num> weeks ago (1 == current week--default)
	commands (and what <cmd_arg> represents) are:
	*  start <timer>     : start the given timer
	*  half <timer>      : start the given timer in half-timing mode
	*  pause <timer>     : pause all timers, or pause availability if <timer> is `:AVAILABILITY'
	*  total <timer>     : total of timers for the first week containing <timer>
	*  eod <date>        : total of timers for a given date
	*  breakdown <timer> : break down <timer> into chunks and display times and durations of each chunk
	*  daybreak <date>   : show all the chunks for a given date
	*  review <prefix>   : total of timers by ticket (all weeks) where timer has a ticket and name begins with <prefix>
-

my $cmd = shift;
my $arg = shift;
my ($tname, $today, $prefix);
if ($cmd eq 'eod' or $cmd eq 'daybreak')
{
	$today = $arg // get_date(time());
}
elsif ($cmd eq 'review')
{
	$prefix = $arg // '';
}
else
{
	$tname = $arg;
}

my ($group_found, $timer_found, $avail_found) = (0,0,0);
my ($in_week, $cur_week) = (0,0);
$today = time2str('%Y/%m/%d', scalar parsedate($today)) if $today;
my (%totals, @daybreak, %review, @mondays);

my $processed_labels = 0;
while ( <> )
{
	if (/^\s*$/)
	{
		if ( $processed_labels )
		{
			$in_week = 0;
			if ( $cmd ~~ [qw< total eod daybreak >] )
			{
				if ($group_found)
				{
					if ($cmd eq 'daybreak')
					{
						breakdown(sort @daybreak);
					}
					else
					{
						my $total = my $lines = 0;
						push @mondays, $totals{':MINDATE'} if $OPT{a};
						$totals{':MINDATE'} ||= 'N/A';
						$totals{':MAXDATE'} ||= 'N/A';
						print "time from $totals{':MINDATE'} to $totals{':MAXDATE'}:\n" if $cmd eq 'total';
						foreach (sort keys %totals)
						{
							next if /^:/;
							$total += $totals{$_};
							++$lines;
							print_time($_, $totals{$_});
						}
						print_time("GRAND TOTAL", $total) if $lines > 1;
						print_time("AVAILABILITY", $totals{$AVAIL}) if $totals{$AVAIL};
					}
					exit unless $OPT{a};
					say '';
					$group_found = 0;
				}
				else
				{
					undef %totals;
				}
			}
		}

		print unless $cmd ~~ [qw< breakdown total eod daybreak review >];
		next;
	}

	chomp;
	my ($name, $chunks, @stuff) = split("\t");
	$chunks ||= '';
	if ( $name )
	{
		if ( $name =~ /:$/ )
		{
			$processed_labels = 1;
		}
		else
		{
			if ( !$in_week )
			{
				++$cur_week;
				$in_week = 1;
			}
			$processed_labels = 0;
		}
	}

	if ($chunks and substr($chunks, -1, 1) eq '-' and ($cmd eq 'start' or $cmd eq 'half' or $cmd eq 'pause'))
	{
		$chunks .= time() . ',' unless $name eq $AVAIL and $tname ne $AVAIL;
	}
	if ( $cmd ~~ [qw< start half >] )
	{
		if ($name eq $tname and !$timer_found)
		{
			$timer_found = 1;
			$chunks .= ($cmd eq 'half' ? '2/' : '') . time() . '-';
		}
		elsif ($name eq $AVAIL and !$avail_found)
		{
			$avail_found = 1;
			$chunks .= time() . '-' unless $chunks =~ /-$/;
		}
	}

	if ($cmd eq 'breakdown')
	{
		if ($name eq $tname and $cur_week >= ($OPT{w} // 1))
		{
			breakdown(split(',', $chunks));
			exit unless $OPT{a};
		}
		next;
	}
	elsif ( $cmd ~~ [qw< total eod daybreak >] )
	{
		if ($cur_week >= ($OPT{w} // 1))
		{
			$group_found = 1 if $cmd eq 'total' and $name eq $tname;
			my $sub;
			if ( $name =~ s/:$// )
			{
				if (@stuff)
				{
					$sub = sprintf("%-20s  [%s]", $name, $stuff[-1]);
					$totals{$sub} = delete $totals{$name} if exists $totals{$name} and not exists $totals{$sub};
				}
				next;
			}
			else
			{
				$sub = $name;
				$sub =~ s/(-nw)+$//;
			}
			foreach (split(',', $chunks))
			{
				warn("no from time on timer $name, line $.") if /^-/;
				warn("bad time on timer $name, line $.") unless /^\d/;
				my ($min, $max) = date_range($_);
				if ($cmd eq 'eod' and $min eq $today)
				{
					$group_found = 1;
					$totals{$sub} += total_chunk($_);
				}
				elsif ($cmd eq 'daybreak' and $min eq $today and $name ne $AVAIL)
				{
					$group_found = 1;
					push @daybreak, "$_:$name";
				}
				elsif ($cmd eq 'total')
				{
					$totals{$sub} += total_chunk($_);
					$totals{':MINDATE'} = $min if not $totals{':MINDATE'} or $min lt $totals{':MINDATE'};
					$totals{':MAXDATE'} = $min if not $totals{':MAXDATE'} or $min gt $totals{':MAXDATE'};
				}
			}
		}
		next;
	}
	elsif ($cmd eq 'review')
	{
		if ($name =~ /^$prefix/)
		{
			if ($name =~ s/:$//)
			{
				$review{$name}->{ticket} = $stuff[-1] if $stuff[-1];
				$review{$name}->{descr} = $chunks;
			}
			else
			{
				if ($chunks)
				{
					my $total = sum map { scalar total_chunk($_) } split(',', $chunks);
					$review{$name}->{total} += $total;
					if ($OPT{v})
					{
						my $min = minstr map { $_ ? (date_range($_))[0] : () } split(',', $chunks);
						my $max = maxstr map { $_ ? (date_range($_))[1] : () } split(',', $chunks);
						print_time("time from $min to $max", $total);
					}
				}
			}
		}
		next;
	}

	print join("\t", $name, $chunks, @stuff), "\n";
}

if ($cmd eq 'review')
{
	debuggit(3 => "review hash:", DUMP => \%review);
	print_time(sprintf("%-7s/%-15s [ %-20s ]", $review{$_}->{ticket}, $_, $review{$_}->{descr}), $review{$_}->{total})
			foreach
				sort { $review{$a}->{ticket} cmp $review{$b}->{ticket} }
				grep { $review{$_}->{total} && $review{$_}->{ticket} }
				keys %review;
}

if ($cmd eq 'total' and $OPT{a})
{
	my $DAY = 24 * 60 * 60;
	my $WEEK = 7 * $DAY;
	debuggit(3 => "mondays:", DUMP => \@mondays);
	my @mondays = sort { $a <=> $b } map { int($_ / $WEEK) } map { str2time($_) } @mondays;
	for (1..$#mondays)
	{
		foreach ( ($mondays[$_-1] + 1)..($mondays[$_] - 1) )
		{
			# the beginning of the epoch was a Thursday ... in England
			# in the U.S., it was still Wednesday
			# so, to get a Monday, we have to add 5 days
			my $date = time2str("%m/%d/%Y", $_ * $WEEK + $DAY * 5);
			say STDERR "Missing week: $date";
		}
	}
}


sub get_date
{
	my ($time) = @_;
	debuggit(4 => "get_date: got time", $time);

	# times before 6am are considered "yesterday", so just subtract 6 hours from the actual time
	return time2str("%Y/%m/%d", $time - 60 * 60 * 6);
}


sub date_range
{
	my ($chunks) = @_;
	debuggit(4 => "date_range: got chunk", $chunks);

	$chunks =~ m{^(?:2/)?(\d+).*-(?:(\d+),?)?$};
	return (get_date($1), get_date($2 || time()));
}


sub total_chunk
{
	my ($chunk) = @_;

	my $half = s{^2/}{};
	my ($from, $to) = split('-');

	my $mins = (($to || time()) - $from) / 60;
	$mins /= 2 if $half;
	$mins = round(UP => $mins);

	return wantarray ? ($from, $to, $mins, $half) : $mins;
}


sub print_time
{
	my ($label, $mins) = @_;

	my $hrs = round(DOWN => $mins / 60);
	$mins %= 60;
	printf("%2d hrs, %2d mins : %s\n", $hrs, $mins, $label);
}


sub breakdown
{
	my $total_mins = 0;
	foreach (@_)
	{
		my $tname; s/:([\w-]+)$// and $tname = $1;
		my ($from, $to, $mins, $half) = total_chunk($_);

		$from = localtime($from);
		$to = $to ? localtime($to) : 'current (still timing)';
		my $duration = "$from - $to";
		$duration .= " (half time)" if $half;
		$duration .= " [$tname]" if $tname;
		print_time($duration, $mins);
		#if ($name eq $AVAIL)
		#{
		#	print_time($duration, $mins);
		#}
		#else
		#{
		#	printf("%5d mins : %s\n", $mins, $duration);
		#}
		$total_mins += $mins;
	}
	#printf("%5d mins : TOTAL\n", $total_mins);
	print_time("TOTAL", $total_mins);
}
