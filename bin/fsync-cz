#! /usr/bin/env perl

use myperl::Pxb;
use autodie ':all';

use Fcntl				qw< :mode >;
use Date::Easy;
use Perl6::Form;
use Lingua::EN::Inflect	qw< PL    >;

const my $NAS      => 'taaveren';
const my @MACHINES => qw< caemlyn zadash >;
our %OTHER_MACHINE = (@MACHINES, reverse @MACHINES);
const my $SYNCDIR  => dir('/', var => sync => synology => );


opts <<'-';
	[-D] { [-G] <dir> | -q <file> }
	-q : query one particular <file>
	-G : skip (report but don't ask to cmp) .git/ files
	-D : debug mode (implies -v)
	<dir>  : directory to compare or sync (2-way)
	<file> : file to compare (3-way)
-

my $from = $ENV{LOCALHOSTNAME} // sh('hostname');
my $to   = $OTHER_MACHINE{$from} // fatal("can't determine hostnames from $from");

if ($OPT{q})
{
	my $file = path($OPT{q});
	$file = $file->realpath;
	$SYNCDIR->subsumes($file) or die("I don't think $file is contained on the NAS");
	my %info;
	my @flds = qw< date mode chksum >;
	foreach ($NAS, @MACHINES)
	{
		@{$info{$_}}{@flds} = get_file_info($_, $file);
		print form '{<<<<<<} : {>>>>>>>>} {>>>} {<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<}', $_, @{$info{$_}}{@flds} if $OPT{D};
	}
	my @diff_hosts;
	foreach my $item (qw< chksum date mode >)
	{
		my $thing = { date => 'timestamp', mode => 'permissions', chksum => 'contents' }->{$item};
		my $things = $thing =~ /s$/ ? $thing : PL($thing);
		my %data;
		foreach (keys %info)
		{
			my $datum = $info{$_}->{$item};
			defined $datum or say "There is no $item field for $_!!!!";
			push @{$data{$datum}}, $_;
		}
		given (scalar keys %data)
		{
			say "all $things are identical" when 1;
			say "all $things are completely different!" when 3;
			when (2)
			{
				my ($common, $outlier) = sort { scalar @{$data{$b}} <=> scalar @{$data{$a}} } keys %data;
				my $diff = '';
				given ($item)
				{
					$diff = "(" . file_date($outlier)  . " vs " . file_date($common)  . ")" when 'date';
					$diff = "(" . file_perms($outlier) . " vs " . file_perms($common) . ")" when 'mode';
				}
				print form "{<<<<<<<<<} on {<<<<<<} different from {<<<<<<<<<<<<<<<<<<<}  $diff",
						$thing, $data{$outlier}->[0], join(' and ', @{$data{$common}});
				if ($item eq 'chksum')
				{
					my @hosts = sort { scalar @$a <=> scalar @$b } values %data;
					my $outlier = $hosts[0]->[0];
					# If the outlier is the current host, then the common hosts are the other and
					# the NAS, so just compare current to other.  If the outlier is NOT the current
					# host, then current is one of the two commons, so compare current to outlier.
					@diff_hosts = $outlier eq $from ? ($from, $to) : ($from, $outlier);
				}
			}
			# otherwise:
			say "WTF?!?!?";
		}
	}
	if (@diff_hosts and confirm("Show full diff of the two files?"))
	{
		my %hosts_and_dates   = map  { $_ => $info{$_}->{date}                            } @diff_hosts;
		my %cat_file_for_host = map  { $_ => ($_ eq $from ? '' : "ssh $_ ") . "cat $file" } @diff_hosts;
		my ($left, $right)    = sort { $hosts_and_dates{$a} <=> $hosts_and_dates{$b}      } @diff_hosts;
		my @labels = map {; '--label' => sprintf('%-10s  %s', $_, datetime($hosts_and_dates{$_})) } ($left, $right);
		sh(colordiff => @labels => "<($cat_file_for_host{$left})", "<($cat_file_for_host{$right})");
	}
	exit;
}

@ARGV or usage_error("must supply directory");
my $dir = path(shift);
-d $dir or usage_error("$dir is not a directory");


my @identical;

my @sync = qw< rsync -avz -u >;
sync_from_to($to   => "$to:$dir/", $from => "$dir/");
sync_from_to($from => "$dir/",     $to   => "$to:$dir/");

sub sync_from_to
{
	my ($from_mach, $from_path, $to_mach, $to_path) = @_;
	my @files;
	foreach (sh(@sync => -n => $from_path, $to_path))
	{
		next if /^(sending|receiving) .* list$/;
		last unless $_;
		next if -d "$dir/$_";
		push @files, $_;
	}
	if (@files)
	{
		say "$from_mach => $to_mach: found ", scalar @files, " files to be sync'ed";
		if (confirm "compare individual files?")
		{
			foreach (@files)
			{
				my $file = path($_);
				my $path = $dir->child($file);
				say "file $file is newer on $from_mach";
				next if $OPT{G} and $file =~ m{^\.git/};
				printf("%8s: %s\n", ll_file($to_mach,   $path));
				printf("%8s: %s\n", ll_file($from_mach, $path));
				if (confirm "compare?")
				{
					if (sh(md5sum => $path) eq sh(ssh => $to, md5sum => $path))
					{
						say "files are identical";
						push @identical, $file;
					}
					else
					{
						sh(ssh => $to, cat => $path, '|', diff => '-', $path);
					}
				}
			}
		}
		else
		{
			say "  to be sync'ed:";
			say foreach @files;
		}
		if (confirm "perform update for real?")
		{
			sh(@sync => $from_path, $to_path);
		}
		elsif (@identical and confirm "sync identical files to older dates?")
		{
			sh(rsync => -avz => -n => $to_path, $from_path, (map {; '--include' => $_ } @identical), '--exclude' => '*');
		}
	}
	else
	{
		say "$from_mach => $to_mach: contents appear to be sync'ed";
	}
}

sub ll_file
{
	my ($on, $path) = @_;
	my @cmd = (ls => -ld => $path);
	unshift @cmd, (ssh => $to) unless $on eq $from;
	return $on, scalar sh(@cmd);
}

sub get_file_info
{
	my ($host, $file) = @_;
	$file =~ s{$SYNCDIR}{/volume1} if $host eq $NAS;
	my @cmd = (stat => -c => "%Y", $file, ';', stat => -c => "%f", $file, ';', md5sum => $file);
	@cmd = (ssh => $host, map { "'$_'" } @cmd) unless $host eq $from;
	#unshift @cmd, (ssh => $host) unless $host eq $from;
	my ($date, $mode, $checksum) = shw(@cmd);
}

sub file_date
{
	datetime(shift)->strftime("%F %T");
}
sub file_perms
{
	sprintf "%04o", S_IMODE(hex(shift));
}
