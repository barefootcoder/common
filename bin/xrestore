#! /usr/bin/env perl

use 5.14.0;
use warnings;
use autodie ':all';

use PerlX::bash;
use Getopt::Long;
use Perl6::Slurp;
use Time::HiRes qw< usleep >;


my $desktop_num = 0;
my %DESKTOPS = map { $_ => $desktop_num++ } qw< Main Comms Music Personal >;

my $ME = $0 =~ s|^.*/||r;
sub USAGE
{
	say <<".";

usage: $ME [-v] [-D] [-geometry [<W>x<H>][+<X>+<Y>]] [-desktop <desktop>] [-ps <ps-cmd-line>] "<cmd> [<arg> ...]"
   or: $ME [-v] [-D] -firefox
                   -v : be chatty about it
                   -D : show internal details
             -firefox : restore Firefox windows (FF must be running, selected tabs must be sane)
                  <W> : desired width of the window
                  <H> : desired height of the window
                  <X> : desired X offset of the window
                  <Y> : desired Y offset of the window
            <desktop> : desired desktop of the window (by name)
        <ps-cmd-line> : full command line as seen by `ps` (if different from command to run)
                <cmd> : command to run if process not already running
                <arg> : arguments for the command to be run
        if the process is already running, it is not spawned
.
    exit;
}

my $OPT = {};
GetOptions($OPT,
	'ps=s',
	'geometry=s',
	'desktop=s',
	'firefox',
	'verbose|v',
	'debug|D',
	'help|h',
);
if ($OPT->{geometry})
{
	$OPT->{geometry} =~ /^((\d+)x(\d+))?([+-]\d+)?([+-]\d+)?$/ or die("unknown geometry format");
	$OPT->{width}  = $2;
	$OPT->{height} = $3;
	$OPT->{xoff}   = $4;
	$OPT->{yoff}   = $5;
}
USAGE() if $OPT->{help};
my ($command, $tag);
if ( $OPT->{firefox} )
{
	$tag = $command = 'firefox';
	$OPT->{ps}      = '/usr/lib/firefox/firefox';
	die("you must run Firefox, restore the session, and choose appropriate tabs") unless &get_pid;
}
else
{
	($command)      = @ARGV or die("must specify command");
	$OPT->{ps}    //= $command;
	$OPT->{desktop} = $DESKTOPS{ $OPT->{desktop} } // die("unknown desktop") if $OPT->{desktop};
	$tag            = $command =~ s/ .*$//r;
}


sub info
{
	say STDERR "$ME: @_" if $OPT->{verbose};
}

sub is_zombie (;$)
{
	local $_ = shift if @_;
	return scalar grep { /zombie/ } slurp "/proc/$_/status";
}

sub get_pid ()
{
	state $pid;

	$pid //= do
	{
		my $find_pid = "/usr/bin/pgrep -fx '$OPT->{ps}'";
		my @pids = grep { !is_zombie } bash \lines => $find_pid;
		die("can't identify process (too many candidates)") if @pids > 1;
		info("found pid: $pids[0] [via: $find_pid]") if @pids;
		shift @pids;
	};
}

sub is_visible (;$)
{
	local $_ = shift if @_;
	my ($desktop) = bash \lines => "xdotool get_desktop_for_window $_ 2>/dev/null";
	return $desktop != -1;
}

sub X (@)
{
	state $wid;

	my $pid = get_pid;
	$wid //= do
	{
		my $find_wid = "xdotool search --pid $pid";
		my @wids = grep { is_visible } bash \lines => $find_wid;
		warn("multiple candidate windows (choosing first one)") if @wids > 1 and not $OPT->{firefox};
		info("found wid: $wids[0] [via: $find_wid]") if @wids;
		shift @wids;
	};

	return unless $wid;
	return 1 unless @_;

	my @args = map { /^%W$/ ? $wid : $_ } @_;
	info("doing window operation on pid $pid: $args[0]");
	my $redirect = $OPT->{debug} ? '' : ">/dev/null 2>&1 4>&1";
	my $cmd = "xdotool @args $redirect";
	info("will run: $cmd") if @args and $OPT->{debug};
	bash $cmd;
}

sub cur_desktop_num
{
	bash \words => 'xdotool get_desktop';
}


sub ff_identify_window (;$)
{
	local $_ = shift if @_;
	my ($win_name) = bash \lines => "xdotool getwindowname $_";
	die("cannot get window name for $_") unless $win_name;

	given (lc $win_name)
	{
		return "work"		when /campus explorer/ or /\bce\b/ or /markdown editor/;
		return "personal"	when /\btodo\b/ or /\bourgroceries\b/ or /do not read this blog/ or /perl weekly/;
		return "music"		when /mp3(va\.com| album)/ or /azlyrics/ or /discogs/ or /allmusic/ or /musicbrainz/;
		return "music"		when /rate your music/;

		return "date-easy"	when /metacpan/ or /history of time/ or /leap second/;
		return "map"		when /google maps/;
		return "comms"		when /my drive/ or /miss the point/;

		return "d&d"		when /faerun/ or /\b5e\b/ or /google sheets/;
		return "scapers"	when /\bheroscapers\b/ or /xotli's place/ or /posts for xotli/;
	}
	die("can't identify window: $win_name [$_]");
}


########
# MAIN #
########


# remember current desktop so we can go back there when we're done
my $orig_desktop = cur_desktop_num();
info("currently on desktop $orig_desktop");

if ( $OPT->{firefox} )
{
	print "[$tag] looking for windows ";
	my $find_wids = "xdotool search --pid ${\(get_pid)}";
	my @wids = grep { is_visible } bash \lines => $find_wids;
	info("found ", scalar(@wids), " wids [via: $find_wids]");

	my %wids = map { $_ => ff_identify_window } @wids;
	do { require Data::Printer; Data::Printer::p(\%wids) } if $OPT->{debug};

	print '. found ';
	foreach (keys %wids)
	{
		# put everything on the right desktop
		my $desktop;
		given ( $wids{$_} )
		{
			$desktop = 'Main'		when [qw< work date-easy map	>];
			$desktop = 'Comms'		when [qw< comms					>];
			$desktop = 'Music'		when [qw< music					>];
			$desktop = 'Personal'	when [qw< personal d&d scapers	>];

			die("logic error (no desktop for $_)");
		}
		X set_desktop_for_window => $_ => $DESKTOPS{$desktop};

		# adjust position for the few that need it
		my ($x, $y);
		given ( $wids{$_} )
		{
			($x, $y) = (0, 289)		when 'music';
		}
		X windowmove => $_ => $x, $y if defined $x;
	}
	say '. restored';
}
else
{
	bash "$command >/dev/null 2>&1 &" unless get_pid;
	my $count = 0;
	print "[$tag] looking for process and window ";
	while (1)
	{
		until (get_pid and X)
		{
			print "." if ++$count % 100 == 0;
			usleep 100;
		}
		last if X windowactivate => '--sync' => '%W';
	}
	print '. found ';
	X windowmove => '%W' => $OPT->{xoff}, $OPT->{yoff}    if $OPT->{xoff};
	X windowsize => '%W' => $OPT->{width}, $OPT->{height} if $OPT->{width};
	X set_desktop_for_window => '%W' => $OPT->{desktop}   if $OPT->{desktop};
	say '. restored';
}

# return to original desktop
info("returning to desktop $orig_desktop");
bash "xdotool set_desktop $orig_desktop";
