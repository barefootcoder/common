#! /bin/bash

me=${0##*/}
monitor=false
showall=false
while getopts ":p:g:Madh" opt
do
	case $opt in
		p)	pid=$OPTARG
			;;
		g)	grep=$OPTARG
			;;
		M)	monitor=true
			;;
		a)	showall=true
			;;
		d)	debug=1
			;;
		h)	echo "usage: $me [-h] [ { -p <pid> | -g <procname> | [-a] [<tty>] } ]" >&2
			echo "         -a : include all descendant processes, even those with different ttys" >&2
			echo "         -p : display complete parentage of <pid> instead of a tty" >&2
			echo '         -g : display complete parentage of `pgrep -f <procname>` instead of a tty' >&2
			echo "         -h : this help message" >&2
			echo "      <pid> : PID to display parentage of" >&2
			echo " <procname> : procname to search for (must be unique)" >&2
			echo "      <tty> : display processes for given tty (default: current tty)" >&2
			exit
			;;
		:)	echo "$me: $OPTARG requires an argument ($me -h for help)" >&2
			exit 2
			;;
		\?)	echo "$me: unknown argument $OPTARG ($me -h for help)" >&2
			exit 2
			;;
	esac
done
shift $(( $OPTIND - 1 ))


function get_ppid
{
	/bin/ps h -o ppid -p $1
}

function get_childpids
{
	local pid=$1
	local depth=${2:-0}
	local max_depth=${3:-50}

	# Stop if we've gone too deep
	if [[ $depth -ge $max_depth ]]
	then
		return
	fi

	[[ $debug == 1 ]] && echo "DEBUG: get_childpids($pid) depth=$depth" >&2
	local children=$(/bin/ps h -o pid --ppid $pid 2>/dev/null)
	[[ $debug == 1 ]] && echo "DEBUG:   children of $pid: $children" >&2
	local all_descendants=""

	for child in $children
	do
		all_descendants="$all_descendants,$child"
		local grandchildren=$(get_childpids $child $(( depth + 1 )) $max_depth)
		if [[ -n $grandchildren ]]
		then
			all_descendants="$all_descendants,$grandchildren"
		fi
	done

	echo ${all_descendants#,}
}


if [[ -n $grep ]]
then
	pid="$(pgrep -f $grep | grep -v "^$$"'$' )"
	if [[ $(echo "$pid" | wc -l) != 1 ]]
	then
		echo "$me: more than one process matches: "$pid >&2
		exit 1
	fi
fi

ps_out="-o pid -o ppid -o user -o stat=S -o stime -o cputime -o tty -o command"
$monitor && ps_out="-o pid -o ppid -o pgid -o command"
if [[ -z $pid ]]
then
	tty=$1
	if [[ -z $tty ]]
	then
		tty=$(tty)
	fi

	if [[ -n $tty ]]
	then
		$monitor || echo TTY is $tty
	fi

	if $showall
	then
		# Get all processes on this TTY and their descendants
		# Only start from top-level processes (whose parent is not also on this TTY)
		all_pids=""
		tty_pids=$(ps -t $tty -o pid= 2>/dev/null | tr '\n' ' ')
		for tty_pid in $tty_pids
		do
			ppid=$(get_ppid $tty_pid | tr -d ' ')
			# Skip if parent is also on this TTY (not a root process)
			if [[ " $tty_pids " == *" $ppid "* ]]
			then
				[[ $debug == 1 ]] && echo "DEBUG: skipping tty_pid=$tty_pid (parent $ppid also on TTY)" >&2
				continue
			fi
			[[ $debug == 1 ]] && echo "DEBUG: processing tty_pid=$tty_pid (top-level)" >&2
			all_pids="$all_pids,$tty_pid"
			children=$(get_childpids $tty_pid)
			[[ $debug == 1 ]] && echo "DEBUG: children=$children" >&2
			if [[ -n $children ]]
			then
				all_pids="$all_pids,$children"
			fi
		done
		all_pids=${all_pids#,}
		exec /bin/ps f -p $all_pids $ps_out
	else
		exec /bin/ps ft$tty $ps_out
	fi
else
	orig_pid=$pid
	all_pids=$pid
	while [[ $pid -ne 1 ]]
	do
		ppid=$(get_ppid $pid)
		if [[ -z $ppid ]]
		then
			echo "$me: no such process $pid" >&2
			exit 1
		fi
		all_pids="$all_pids,$ppid"
		pid=$ppid
	done
	all_pids="$all_pids,$(get_childpids $orig_pid)"
	all_pids=${all_pids// /}

	[[ $debug == 1 ]] && echo DEBUG: /bin/ps f -p $all_pids -g $orig_pid $ps_out >&2
	exec /bin/ps f -p $all_pids -g $orig_pid $ps_out
fi
