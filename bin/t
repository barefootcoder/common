#! /usr/bin/env perl

use 5.010;
use autodie qw< :all >;
use warnings FATAL => 'all';

sub check_prereqs
{
	foreach (qw< Getopt::Std Path::Class Perl6::Slurp Time::Duration List::MoreUtils Time::HiRes >)
	{
		eval "require $_" or system(qw< cpanm -n >, $_);
	}
}
BEGIN { check_prereqs() }

use Getopt::Std;
use Path::Class;
use Perl6::Slurp;
use Time::Duration;
use List::MoreUtils qw< uniq >;
use Time::HiRes qw< gettimeofday tv_interval >;

my $start_time; BEGIN { $start_time = [gettimeofday]; }
END { local $Time::Duration::MILLISECOND = 1; say "Runtime: ", duration_exact(tv_interval($start_time)); }

sub print_color(@);


$| = 1;

my $opt = { N => '', };
getopts("hnaTcvsAPDN:m:", $opt);

# help message
if ($opt->{h})
{
	my $me = $0;
	$me =~ s@^.*/@@;

	print "usage: $me -h | [-naTcvsAPD] [-Nlrj] [-m method_name] [perl_module|t_dir]\n";
	print "       run tests associated with perl_module\n";
	print "           -h: this help message\n";
	print "           -n: only run the newest (most recently modified) test file\n";
	print "           -a: run all tests (i.e. don't bail on fail)\n";
	print "           -T: run tests with taint checking on\n";
	print "           -c: try to run tests under Devel::Cover and report (forces -Nj)\n";
	print "           -v: run tests in verbose mode\n";
	print "           -s: show only test summary\n";
	print "           -A: load Carp::Always to get full stack traces on errors\n";
	print "           -P: load Test::Pretty to get nicer test output (forces -Nj)\n";
	print "           -D: debug mode\n";
	print "           -N: do not pass the following switch(es) to prove (must combine multiples)\n";
	print "                  -Nl: do not add -Ilib for your tests (default: prove -l)\n";
	print "                  -Nr: do not run recursively (default: prove -r)\n";
	print "                  -Nj: do not parallelize tests (default: prove -jN [unless -c or -P])\n";
	print "                          default N: number of CPU cores + 1\n";
	print "           -m: only run a single test method in the specified file\n";
	print "                  this only works with Test::Class-style tests\n";
	print "                  you can specify a partial name; if it is ambiguous, it is an error\n";
	print "                  this probably doesn't work with multiple files\n";
	exit;
}


###########################
###  QUICK HACKS
###########################


# quick hack: shortcut to spawning dzil test if:
# 	a) we can find a "dist.ini"
# 	b) we're called with no args (that includes switches!)
# alternately, we could call rent if:
#	a) we're in the packages/ directory, or a subdir thereof
#	b) we have no args, and only -n and/or -v switches
# we can't allow switches because there's no reliable way to pass them on to dzil
# (although rent specifically handles -v and -n, so those are okay)
$ENV{RELEASE_TESTING} = 1;
if (-r 'dist.ini')
{
	if (dir()->absolute =~  m{/packages/})
	{
		if (not @ARGV)
		{
			my $opts = '';
			$opts .= " -v" if delete $opt->{v};
			$opts .= " -n" if delete $opt->{n};
			if (%$opt)
			{
				die("Sorry! can't figure out how to run `rent' with switches: " . join(', ', keys %$opt));
			}
			else
			{
				$ENV{'RENT_DEV_YES'} = 1;
				exec("rent test $opts");
			}
		}
	}
	else
	{
		exec("dzil test && dzil clean") if not %$opt and not @ARGV;
	}
}


# another quick hack:
# if we see evidence that we're going to be using blib/lib/ instead of lib/, we probably better run
# make to make sure the library file is copied to blib/lib/
system("make") if -d 'blib/lib' and -e 'Makefile';


my $precommand;															# will be executed just before main command is run
my $postcommand;														# executes after command, but *only* if successful
# slightly less quick hack:
# if we're in a Dist::Zilla distro and we _do_ get arguments, we _may_ be able to set up an
# environment where prove will work properly ...
if (-r "dist.ini" and @ARGV)
{
	$precommand = sub
	{
		system("dzil build");
		# the dir we want is the same as the tarfile sans extension
		(my $dir = glob("*.tar.gz")) =~ s/\.tar\.gz$//;
		-d $dir or die("can't figure out build directory");
		chdir $dir;
		system("$^X Makefile.PL");
		system("make");
	};

	$postcommand = sub
	{
		chdir '..';
		system("dzil clean");
	}
}


###########################
###  THE MAIN EVENT
###########################


#
# set up cover stuff
# 		[ -c switch ]
#

my $coverdb = '/tmp/cover_db';
my $cover = "cover";
$cover .= " -silent" unless $opt->{D};
my $HARNESS = 'HARNESS_PERL_SWITCHES';
if ($opt->{c})
{
	eval { require Devel::Cover } or die("$0: Devel::Cover not found [ $@ ]\n");
	my $command = "$cover -delete $coverdb";
	print STDERR "running: $command\n" if $opt->{D};
	system($command);
	$ENV{$HARNESS} = "-MDevel::Cover=-db,$coverdb";
}

#
# set up Test::Pretty stuff
# 		[ -P switch ]
#

if ($opt->{P})
{
	eval { require Test::Pretty } or die("$0: Test::Pretty not found [ $@ ]\n");
}


#
# find the right directory
#

my ($dir, @files);
my $arg = shift;
if ($arg)
{
	if ( $arg =~ /\.(t|pm)$/ )
	{
		@files = ($arg);
	}
	else
	{
		my ($pkg, @possibles);
		if ( my $file = identify_perl_module($arg) )
		{
			$pkg = $arg;
			$dir = file($file)->dir;
		}
		elsif (-f $arg)
		{
			$pkg = get_pkgname($arg);
			print STDERR 'got package: ', defined $pkg ? $pkg : '<<undef>>', "\n" if $opt->{D};
		}
		$pkg =~ s/::/-/g if $pkg;

		my @dirs = get_workenv('test_dirs');
		if (@dirs)
		{
			# if we get this far, we're running in a work environment
			(my $d = $arg) =~ s{::}{/}g;
			foreach my $t_dir ( @dirs )
			{
				push @possibles, "$WORKDIR/$t_dir/$d/t";
				push @possibles, "$WORKDIR/$t_dir/$d";
				push @possibles, "$WORKDIR/$t_dir/$pkg" if $pkg;
			}
		}

		push @possibles, "$arg/t", $arg;
		push @possibles, "t/$arg" if $arg and $arg !~ m@^/@;
		push @possibles, "t/$pkg" if $pkg;
		@possibles = uniq @possibles;
		push @possibles, map { dir($dir)->file($_) } @possibles if $dir;

		my $found = find_dest(@possibles);
		-d $found ? ($dir = $found) : push @files, $found if $found;
	}
}

# if we haven't found the directory/files yet, better try harder
if (not $dir and not @files)
{
	$dir = find_dest("t", "../t", "../../t", "../../../t");
}
die("$0: cannot figure out where test files are\n") unless $dir or @files;

@files = get_files($dir) unless @files;

# use requested modules
my %req_modules =
(
	A	=>	'Carp::Always',
);
$ENV{PERL5OPT} = join(' ', map { $opt->{$_} ? "-M$req_modules{$_}" : () } keys %req_modules);

# set test method if requested
if ($opt->{m})
{
	my $sub = qr/\w*$opt->{m}\w*/;
	my @candidates = map { /sub\s+($sub)\s*:\s*Test/ ? $1 : () } map { slurp } @files;
	if (@candidates == 0)												# too few
	{
		die("$0: can't find method *$opt->{m}*");
	}
	elsif (@candidates > 1)												# too many
	{

		die("$0: method pattern *$opt->{m}* is ambiguous (", join(',', @candidates), ")");
	}
	else																# just right
	{
		$ENV{TEST_METHOD} = $candidates[0];
	}
}

$ENV{BAIL_ON_FAIL} = 1 unless $opt->{a};
print "testing @files ", $ENV{TEST_METHOD} ? "[$ENV{TEST_METHOD}] " : '', "...\n";


print "\n" x 10 unless $opt->{s};
$precommand->() if $precommand;

my @prove_args;
push @prove_args, '-c' if -t STDOUT;
push @prove_args, '-v', '--merge' if $opt->{v};
push @prove_args, '-Q' if $opt->{s};
push @prove_args, '-T' if $opt->{T};
push @prove_args, -d 'blib' ? '-Iblib/lib' : '-l' unless $opt->{N} =~ /l/;
push @prove_args, '-r' unless $opt->{N} =~ /r/;
unless ($opt->{N} =~ /j/ or $opt->{c} or $opt->{P})
{
	my $cpuinfo = '/proc/cpuinfo';
	my $num_cores = -r $cpuinfo ? ()= grep { /^processor/ } slurp $cpuinfo : 4;
	my $num_procs = $num_cores + 1;
	push @prove_args, "-j$num_procs";
}
push @prove_args, '-PPretty' if $opt->{P};
push @prove_args, map { "-I$_" } split(':', $ENV{PERL5LIB}) if $opt->{T} and $ENV{PERL5LIB};
push @prove_args, @files;
push @prove_args, get_workenv('post_args');
my $command = "prove @prove_args";
print STDERR "running: $command\n" if $opt->{D};
print STDERR "         (with BAIL_ON_FAIL=$ENV{BAIL_ON_FAIL})\n" if $opt->{D} and not $opt->{a};
print STDERR "         (with $HARNESS=$ENV{$HARNESS})\n" if $opt->{D} and $opt->{c};
print STDERR "         (with PERL5OPT=$ENV{PERL5OPT})\n" if $opt->{D} and grep { $opt->{$_} } keys %req_modules;
print STDERR "         (with TEST_METHOD=$ENV{TEST_METHOD})\n" if $opt->{D} and $opt->{m};
if ($opt->{c})
{
	open(PIPE, "$command 2>&1 |") or die("$0: can't run prove\n");
	while ( <PIPE> )
	{
		# ignore errors from Devel::Cover
		next if /^Devel::Cover: Can't open accessor/;
		next if /^Can't find digest for accessor/;
		next if /^Deep recursion on subroutine "B::Deparse::deparse".*Devel\/Cover\.pm/;
		print;
	}
	close(PIPE);
}
else
{
	system($command);
}
if ($?)
{
	print_color red => "\nTEST FAILURE\n";
	exit 1;
}

$postcommand->() if $postcommand;
print_color green => "\nALL TESTS PASSED\n";


# Devel::Cover reporting

if ($opt->{c})
{
	my $pretty_arg = prettify_dir($arg);
	#my $base_arg = fileparse($arg, qr/\..*$/);
	my ($base_arg) = file($arg)->basename =~ /^(.*)\.?/;
	print "\n\nResults from Devel::Cover for $pretty_arg:\n\n";

	my $command = "$cover -select $arg -report text $coverdb";
	print STDERR "running: $command\n" if $opt->{D};
	open(PIPE, "$command 2>&1 |") or die("$0: can't run cover\n");
	my $section = 0;
	while ( <PIPE> )
	{
		next if /^Devel::Cover: Can't find digest for/;
		next if /^Devel::Cover: ignoring extra/;
		#last if /^Run:/;

		++$section if /^\s*-----/ and $section < 4;
		$section = 4 if /^Run:/;
		$section = 5 if m@^/@;
		$section = 6 if /^Covered Subroutines/;

		if ($section == 2)
		{
			print if /$base_arg/ and not /\.t\b/;
			next;
		}

		next if $section == 4;
		next if $section == 5;
		next if $section == 6;

		print;
	}
	close(PIPE);
}


###########################
###  SUBS
###########################


our $WORKDIR;
sub get_workenv
{
	my ($param) = @_;
	state $WORKENV =
	{
		Rent	=>	{
						env_var		=>	[ 'WEBROOT', 'RENT_HOME' ],
						test_dirs	=>	[qw< lib/Test/t lib/Company/t >],
					},
		CE		=>	{
						env_var		=>	[ 'CEROOT' ],
						test_dirs	=>	[qw< t/lib tlib >],
						post_args	=>	[qw< :: --database cetest >],
					},
	};
	state $CURENV;

	unless (defined $CURENV)
	{
		foreach my $env (keys %$WORKENV)
		{
			my $env_vars = $WORKENV->{$env}->{env_var};
			foreach (@$env_vars)
			{
				if (exists $ENV{$_})
				{
					$WORKDIR = $ENV{$_};
					next unless -d $WORKDIR;
					$CURENV = $env;
					last;
				}
			}
			last if $CURENV;
		}
		$CURENV //= 0;													# i.e., false but not undefined
	}

	return $CURENV ? @{ $WORKENV->{$CURENV}->{$param} } : ();
}


sub get_pkgname
{
	if (local $_ = shift)
	{
		print STDERR "opening file: $_\n" if $opt->{D};
		open(IN, $_) or return undef;
		print STDERR "reading file: $_\n" if $opt->{D};
		while ( <IN> )
		{
			# skip pod
			next if /^=/../^=cut/;

			if ( /package\s+(.*?);/ )
			{
				return $1;
			}
		}
		close(IN);
	}

	return undef;
}


sub identify_perl_module
{
	my ($mod) = @_;

	if (eval "require $mod")
	{
		print STDERR "identified as a module: $mod\n" if $opt->{D};
		$mod =~ s{::}{/}g;
		return $INC{"$mod.pm"};
	}

	return undef;
}


sub find_dest
{
	foreach (@_)
	{
		next unless $_;
		print STDERR "checking destination: $_\n" if $opt->{D};
		if (-f "$_.pm")
		{
			return prettify_dir("$_.pm");
		}
		elsif (-d)
		{
			return prettify_dir($_);
		}
	}
	return undef;
}


sub prettify_dir
{
	local $_ = shift;

	# just makes for a prettier display
	my $cwd = dir->absolute();
	if ($_ eq $cwd)
	{
		return '.';
	}
	else
	{
		eval { s@^$cwd//?@@ };
	}

	return $_;
}


sub get_files
{
	local $_ = shift;
	print STDERR "found directory $_\n" if $opt->{D};

	if (-e "$_/test_manifest" and not $opt->{n})
	{
		require Test::Manifest;
		# Test::Manifest doesn't do recursion or parallelization
		$opt->{N} .= 'rj';
		return scalar(Test::Manifest::get_t_files(0));
	}
	else
	{
		my $glob = $opt->{N} =~ /r/ ? "$_/*.t" : `find $_ -name '*.t'`;
		$glob =~ s/\n/ /g;

		if ($opt->{n})
		{
			my $latest = `/bin/ls -1t $glob | head -n1`;
			chomp $latest;

			return $latest;
		}
		else
		{
			return $_;
		}
	}
}


sub print_color (@)
{
	my ($color, $msg) = @_;

	if (-t STDOUT)
	{
		require Term::ANSIColor;
		print Term::ANSIColor::colored($msg, $color);
	}
	else
	{
		print $msg;
	}
}
