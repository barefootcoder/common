#!/usr/bin/env perl

use myperl DEBUG => 1;

use Date::Format;
use Time::ParseDate;
# line 9


my $this_monday = parsedate("today midnight");
$this_monday = parsedate("last monday midnight") unless time2str('%a', $this_monday) eq 'Mon';
const our $ONE_WEEK => 60 * 60 * 24 * 7;

my $TIMERS = {};
read_timerfile('-new');
my $monday = $this_monday;
while (not exists $TIMERS->{'agile-mtg'})
{
	$monday -= $ONE_WEEK;
	read_timerfile("." . time2str("%Y%m%d", $monday));
	die("too far back") if $this_monday - $monday > $ONE_WEEK * 2;
}

my $sprint_start = $TIMERS->{'agile-mtg'}->{'chunks'}->[-1]->{'to'};
delete $TIMERS->{'agile-mtg'};
remove_earlier($sprint_start);


const our %SP_ROUNDING =>
(
	8	=>	1,
	14	=>	2,
	24	=>	3,
	39	=>	5,
	99	=>	8,
);

$_->{'ticket_sort'} = $_->{'ticket'} || 'ZZ', $_->{'total'} = sum map { $_->{'total'} } @{ $_->{'chunks'} }
	foreach values %$TIMERS;;

my $grand_total = 0;
foreach my $tname (map { $_->[0] } sort { $a->[1] cmp $b->[1] || $b->[2] <=> $a->[2] }
		map { [ $_, $TIMERS->{$_}->{'ticket_sort'}, $TIMERS->{$_}->{'total'} ] } keys %$TIMERS)
{
	next if $tname =~ /^:/;
	my $timer = $TIMERS->{$tname};

	my $total = convert_time_to_hours($timer->{'total'});
	$grand_total += $timer->{'total'};

	my $sp;
	foreach (sort { $a <=> $b } keys %SP_ROUNDING)
	{
		if ($total <= $_)
		{
			$sp = $SP_ROUNDING{$_};
			last;
		}
	}

	print form("{<{40}<}  {<<<<<<<}  {>.0}  {}", $tname, $timer->{'ticket'} || '', $total, $sp);
}
say "\nTotal hours: ", convert_time_to_hours($grand_total);


func read_timerfile ($fname)
{
# line 36
	$fname = "$ENV{HOME}/timer/timer$fname";
	debuggit(2 => "reading file $fname");

	my @paragraphs = slurp $fname, {irs=>qr/\n\n+/};
	shift @paragraphs unless $paragraphs[0];
	my ($timers, $descriptions) = @paragraphs;

	my $t = { map { (split("\t"), '')[0,1] } split("\n", $timers) };
	foreach ( keys %$t )
	{
		next unless $_;
		my @chunks = split(',', $t->{$_});
		foreach (@chunks)
		{
			my $half = s{^2/}{};
			my ($from, $to) = split('-');

			my $mins = (($to || time()) - $from) / 60;
			$mins /= 2 if $half;
			print STDERR "mins is: before--$mins ";
			$mins = round(UP => $mins);
			print STDERR "after--$mins\n";

			$_ =
			{
				from	=>	$from,
				to		=>	$to,
				half	=>	$half,
				date	=>	time2str("%Y/%m/%d", $from - 60 * 60 * 6),	# subtract 6 hours so pre-6am is "yesterday"
				total	=>	$mins,
			}
		}

		$t->{$_} = { chunks => [ @chunks ] };
	}
	debuggit(4 => "final map is", DUMP => $t);

	foreach (split("\n", $descriptions))
	{
		my ($tname, $descr) = split(":\t");
		my $ticket = $descr =~ /([A-Z]{2}-\d{4,5})/ ? $1 : undef;

		if (exists $t->{$tname})
		{
			$t->{$tname}->{'description'} = $descr;
			$t->{$tname}->{'ticket'} = $ticket;
		}
		else
		{
			die("have a description ($tname) for a non-existent timer");
		}
	}

	@{ $t->{$_}->{'chunks'} || [] } || delete $t->{$_} foreach keys %$t;
	debuggit(4 => "compressed map is", DUMP => $t);
	merge_timers($t);
}

func merge_timers ($timers)
{
	const my $SEP => ' // ';

	foreach my $tname (keys %$timers)
	{
		debuggit(3 => "merging timer", $tname);
		if (exists $TIMERS->{$tname})
		{
			my $base_timer = $TIMERS->{$tname};
			my $merge_timer = $timers->{$tname};

			my $base_chunks = $base_timer->{'chunks'};
			my $merge_chunks = $merge_timer->{'chunks'};
			$base_timer->{'chunks'} = [ sort { $a->{'from'} <=> $b->{'from'} } @$base_chunks, @$merge_chunks ];

			my $base_ticket = $base_timer->{'ticket'};
			my $merge_ticket = $merge_timer->{'ticket'};
			die("inconsistent tickets on timer $tname")
					if defined $merge_ticket and defined $base_ticket and $base_ticket ne $merge_ticket;

			my $base_descr = $base_timer->{'description'} || '';
			my $merge_descr = $merge_timer->{'description'} || '';
			my %descr = map { $_ => 1 } split($SEP, $base_descr);
			$base_timer->{'description'} = join($SEP, $base_descr, $merge_descr) if not exists $descr{$merge_descr};
		}
		else
		{
			$TIMERS->{$tname} = $timers->{$tname};
		}
	}
}

func remove_earlier ($time)
{
	foreach my $tname (keys %$TIMERS)
	{
		my $chunks = $TIMERS->{$tname}->{'chunks'};
		shift @$chunks while @$chunks and $chunks->[0]->{'from'} < $time;
		delete $TIMERS->{$tname} if not @$chunks;
	}
}


func convert_time_to_hours ($time)
{
	return round($time / 60, .25);
}
