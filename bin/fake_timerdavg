#! /usr/bin/env perl

use myperl DEBUG => 1;
use myperl::Script;
use autodie ':all';

use POSIX qw< ceil >;


opts <<'-';
	[-vD] [-w<N>]
	-v : be more verbose
	-D : debugging mode
	-w : only look back <N> weeks
	-O : identify outliers
	<N>    : number of weeks (default: all weeks)
-


my ($min_date, $max_date, $total_time, $total_avail) = time_and_avail("$ENV{HOME}/timer/timer-new");
my $num_days = num_weekdays($min_date, $max_date);

if ($OPT{v})
{
	say "Time from: ", $min_date->as('/Ymd');
	say "       to: ", $max_date->as('/Ymd');
	say "     days: $num_days";
	say "     time: $total_time";
	say '';
}

say "      Number of days: $num_days";
say "        Average time: ", $total_time / $num_days;
say "Average availability: ", $total_avail / $num_days;
#say "      Time Remaining: ", print_time( (30 - $this_week) + ($num_weeks * 30 - $total_time) );

if ($OPT{v})
{
	say '';
	my $num_weeks = $num_days / 5;
	say "   Number of weeks: $num_weeks";
	say "Total availability: $total_avail";
	say "          Avg time: ", $total_time / $num_weeks;
	say "  Avg availability: ", $total_avail / $num_weeks;
	my $pct = $total_time / $total_avail;
	say "              %age: ", 100 * $pct;
	my $next_week = (ceil($num_weeks)+1) * 40 - $total_avail;
	say "         Next week: $next_week / ", $next_week * $pct;
}


func num_weekdays ($from, $to)
{
	use Date::Gregorian::Business;
	use Date::Gregorian qw< :weekdays >;

	# create a date with a calendar with normal weekends, but no holidays
	my $date = Date::Gregorian::Business->new([ [ SATURDAY, SUNDAY ], [] ]);
	$date->set_ymd($from->split);

	return $date->get_businessdays_until(Date::Gregorian->new->set_ymd($to->split)) + 1;
}


func time_and_avail ($file)
{
	my ($time, $avail) = (0,0);
	state $OUTLIER_RANGES = { 'GRAND TOTAL' => [25 => 35], AVAILABILITY => [35 => 55] };

	my $min_date = today;
	my $max_date = today;
	my $how_far = $OPT{w} ? '-w' . ($OPT{w} + (today->day_of_week < 4)) : '';
	my $timer_cmd = "fake_timer -a $how_far total email $file";
	say "running: $timer_cmd" if $OPT{D};
	open(IN, "$timer_cmd |") or die("can't open pipe");
	while ( <IN> )
	{
		# time from 2013/07/15 to 2013/07/19:
		my $date = qr{\d{4}/\d{2}/\d{2}};
		if ( m{time from ($date) to ($date)} )
		{
			print "$file : $_" if $OPT{D};
			$min_date = min($min_date, date($1));
			$max_date = max($max_date, date($2));
		}

		#  0 hrs, 36 mins : cpan
		my ($hrs, $mins, $timer) = /^ \s* (\d+) \s+ hrs, \s+ (\d+) \s+ mins \s* : \s* (.+) $/x;
		next unless $timer and ( $timer eq 'GRAND TOTAL' or $timer eq 'AVAILABILITY' );

		if ($OPT{D})
		{
			say "$file :   $timer $hrs:$mins";
		}
		my $timer_hours = $hrs + $mins / 60;
		if ( $OPT{O} and $timer ~~ [keys %$OUTLIER_RANGES] )
		{
			my $this_week = $timer_hours - ($timer eq 'AVAILABILITY' ? $avail : $time);
			my $range     = $OUTLIER_RANGES->{$timer};
			say "OUTLIER! ", join(' - ', map { $_->as("/Ymd") } $min_date, $min_date + 6 * days), " : $this_week $timer"
					unless $range->[0] <= $this_week and $this_week <= $range->[1];
		}
		$time = $timer_hours if $timer eq 'GRAND TOTAL';
		$avail = $timer_hours if $timer eq 'AVAILABILITY';
	}
	close(IN);

	debuggit(4 => "for file", $file, "time is", $time, "and avail is", $avail);
	return wantarray ? ($min_date, $max_date, $time, $avail) : $time;
}


func print_time ($time)
{
	$time = round($time, .25);
	my $hrs = int($time);
	my $mins = abs( ($time - $hrs) * 60 );

	return sprintf("%2d:%02d", $hrs, $mins);
}
