#! /bin/bash

me=${0##*/}																# slightly prettier than $0
readonly me


function capture_git
{
	do_git $pretend 0 "now running:" "$1"
}

function run_git
{
	do_git $pretend $pretend "would run:  " "$1"
}

function do_git
{
	local say_it=$1
	local skip_it=$2
	local msg=$3
	local cmd="git $4"
	[[ $say_it == 1 ]] && echo -e "\e[96m\e[1m$msg\e[0m\e[1m $cmd\e[0m" >&2
	[[ $skip_it == 0 ]]  && eval $cmd
}


function Mainline
{
	eval "local $(grep VCtoolsDir ~/.vctools/vctools.conf)"
	$VCtoolsDir/bin/vc info %Mainline
}

function current_branch
{
	eval "local $(grep VCtoolsDir ~/.vctools/vctools.conf)"
	branch=$($VCtoolsDir/bin/vc info %cur_branch)
	if [[ $branch == "HEAD" ]]
	then
		echo "$me: can't show branch logs with a detached HEAD" >&2
		exit 1
	fi
	echo $branch
}


function branched_from
{
	branch="$1"
	# this will not work properly if a branch was somehow branched from multiple branches
	# however, I can't think this could possibly happen
	# additonally, it might be slow for branches with lots and lots of commits
	local proglet='@b = grep { s/^  // } `git branch --no-color --contains $_` and print $b[0] and exit'
	capture_git "rev-list --no-merges HEAD | perl -lne '$proglet'"
}

function all_unpushed
{
	origin_branch=origin/$(current_branch)
	if ! git branch -r | fgrep -q $origin_branch
	then
		origin_branch=origin/$(Mainline)
	fi
	for ref in $(capture_git "log --pretty=%h $origin_branch..HEAD")
	do
		if [[ ! $(capture_git "branch -r --contains $ref | grep origin/") ]]
		then
			commits="$commits $ref"
		fi
	done
	echo "$commits"
}

cmd="log"

args=''
patcharg='-s'
show_merges=0
show_branch=0
show_local=0
show_me=0
pretend=0
grep_diffs=0
date_format=local
while getopts ":vdscHNpbln:LmU:g:RGh" opt
do
	case $opt in
		v)	show_merges=1
			if [[ $patcharg == "-p" ]]
			then
				patcharg='-p --stat'
			else
				patcharg='--stat'
			fi
			;;
		d)	if [[ $patcharg == "--stat" ]]
			then
				patcharg='-p --stat'
			else
				patcharg='-p'
			fi
			if [[ $grep_diffs != 0 ]]
			then
				args="$args -G $grep_diffs"
			fi
			grep_diffs=1
			;;
		s)	args="$args --oneline"
			;;
		H)	args="$args --pretty=%h"
			;;
		c)  args="$args --oneline"
			post="wc -l"
			;;
		N)  show_merges=1
			post="perl -lpe 's/^((\e.+m)?(commit )?[0-9a-f]{7,})/sprintf(q{%3d %s}, ++\$n, \$1)/e' | ${PAGER:-less}"
			;;
		p)	pretend=1
			;;
		b)	show_branch=1
			;;
		L)	show_local=1
			;;
		l)	args="$args -n1"
			;;
		n)	args="$args -n$OPTARG"
			;;
		m)  show_me=1
			;;
		U)  args="$args --author $OPTARG"
			;;
		g)	if [[ $grep_diffs == 0 ]]
			then
				args="$args --grep '$OPTARG'"
			else
				args="$args -G $OPTARG"
			fi
			grep_diffs="$OPTARG"
			;;
		R)	args="$args --reverse"
			;;
		G)	date_format=gmt
			;;
		h)  echo "usage: $me -h | [-{v|d|s|H} [-NG] | -c] [-p] [-b | -L] [-l | -nX] [-m | -Uuser] [-g regex] [file ...]" >&2
			echo "    -v : verbose (show files changed, include merge commits)" >&2
			echo "    -d : show diffs of changed files" >&2
			echo "    -s : show short (one-line) format for commits" >&2
			echo "    -H : show only SHA1s (even shorter than short format)" >&2
			echo "    -N : number commits (first commit marked 1, second 2, etc; includes merge commits)" >&2
			echo "    -G : display dates in GMT/UTC format" >&2
			echo "    -c : don't show commits, just count them" >&2
			echo "    -p : pretend (show git command to be run, but don't run it)" >&2
			echo "    -b : show only commits on the current branch (no merges unless -v or -N)" >&2
			echo "    -L : show only commits not yet pushed to server (no merges unless -v or -N)" >&2
			echo "    -l : show only latest commit (same as -n1)" >&2
			echo "    -n : show only X commits (default: show all)" >&2
			echo "    -m : show only my commits (commits by current user)" >&2
			echo "    -U : show only commits by user" >&2
			echo "    -g : show only commits with log messages containing regex" >&2
			echo "    -R : show commits in reverse order (oldest to newest)" >&2
			echo "    -h : this help message" >&2
			echo "    user : either name or email; can be partial, but is case-sensitive" >&2
			echo "    file : source file (default: entire working tree)" >&2
			exit
			;;
		:)  echo "$me: $OPTARG requires an argument ($me -h for help)" >&2
			exit 2
			;;
		\?) echo "$me: unknown argument $OPTARG ($me -h for help)" >&2
			exit 2
			;;
	esac
done
shift $(( $OPTIND - 1 ))
   [[ $date_format == local ]] && args="$args --date=local"
   [[ $show_me     == 1     ]] && args="$args --author $(capture_git "config user.email")"
   [[ $show_merges == 0     ]] && args="$args --no-merges"
if [[ $show_local  == 1     ]]
then
	cmd="show"
	commits="$(all_unpushed)"
	[[ -z $commits ]] && exit						# no commits to show
	args="$args $commits"
fi
if [[ $show_branch == 1     ]]
then
	branch=$(current_branch)
	from=$(branched_from $branch)
	args="$args $from..$branch"
fi


cmd="$cmd $patcharg $args $*"
if [[ -n $post ]]
then
	cmd="$cmd | $post"
fi

[[ -t 1 && $pretend == 0 ]] && echo -e "\n\n\n\n"
run_git "$cmd"
