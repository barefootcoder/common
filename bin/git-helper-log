#! /bin/bash

me=${0##*/}																# slightly prettier than $0
readonly me


function capture_git
{
	do_git $pretend 0 "now running:" "$1"
}

function run_git
{
	do_git $pretend $pretend "would run:  " "$1"
}

function do_git
{
	local say_it=$1
	local skip_it=$2
	local msg=$3
	local cmd="git $4"
	[[ $say_it == 1 ]] && echo -e "\e[96m\e[1m$msg\e[0m\e[1m $cmd\e[0m" >&2
	[[ $skip_it == 0 ]]  && eval $cmd
}


function current_branch
{
	branch=$(capture_git "branch --contains HEAD | perl -lne 'print if s/^\* //'")
	if [[ $branch == *"no branch"* ]]
	then
		echo "$me: can't show branch logs with a detached HEAD" >&2
		exit 1
	fi
	echo $branch
}

function branched_from
{
	branch="$1"
	# this will not work properly if a branch was somehow branched from multiple branches
	# however, I can't think this could possibly happen
	# additonally, it might be slow for branches with lots and lots of commits
	local proglet='@b = grep { s/^  // } `git branch --contains $_` and print $b[0] and exit'
	capture_git "rev-list --no-merges HEAD | perl -lne '$proglet'"
}

function how_many_unpushed
{
	local MAX=50
	local count=0
	for ref in $(capture_git "log -n$MAX --pretty=%h")
	do
		if [[ $(capture_git "branch -r --contains $ref | grep origin/") ]]
		then
			echo $count
			return
		fi
		count=$(( $count + 1 ))
	done
	echo "$me: more than $MAX unpushed commits" >&2
	exit 1
}

cmd="log"

args=''
show_merges=0
show_branch=0
show_local=0
show_me=0
pretend=0
grep_diffs=0
date_format=local
while getopts ":vdscNpbln:LmU:g:RGh" opt
do
	case $opt in
		v)	show_merges=1
			args="$args --stat"
			;;
		d)	args="$args -p"
			if [[ $grep_diffs != 0 ]]
			then
				args="$args -G $grep_diffs"
			fi
			grep_diffs=1
			;;
		s)	args="$args --oneline"
			;;
		c)  args="$args --oneline"
			post="wc -l"
			;;
		N)  show_merges=1
			post="perl -lpe 's/^((commit )?[0-9a-f]{7,})/sprintf(q{%3d %s}, ++\$n, \$1)/e' | ${PAGER:-less}"
			;;
		p)	pretend=1
			;;
		b)	show_branch=1
			;;
		L)	show_local=1
			;;
		l)	args="$args -n1"
			;;
		n)	args="$args -n$OPTARG"
			;;
		m)  show_me=1
			;;
		U)  args="$args --author $OPTARG"
			;;
		g)	if [[ $grep_diffs == 0 ]]
			then
				args="$args --grep $OPTARG"
			else
				args="$args -G $OPTARG"
			fi
			grep_diffs="$OPTARG"
			;;
		R)	args="$args --reverse"
			;;
		G)	date_format=gmt
			;;
		h)  echo "usage: $me -h | [-{v|d|s} [-NG] | -c] [-p] [-b | -L] [-l | -nX] [-m | -Uuser] [-g regex] [file ...]" >&2
			echo "    -v : verbose (show files changed, include merge commits)" >&2
			echo "    -d : show diffs of changed files" >&2
			echo "    -s : show short (one-line) format for commits" >&2
			echo "    -N : number commits (first commit marked 1, second 2, etc; includes merge commits)" >&2
			echo "    -G : display dates in GMT/UTC format" >&2
			echo "    -c : don't show commits, just count them" >&2
			echo "    -p : pretend (show git command to be run, but don't run it)" >&2
			echo "    -b : show only commits on the current branch (no merges unless -v or -N)" >&2
			echo "    -L : show only commits not yet pushed to server (no merges unless -v or -N)" >&2
			echo "    -l : show only latest commit (same as -n1)" >&2
			echo "    -n : show only X commits (default: show all)" >&2
			echo "    -m : show only my commits (commits by current user)" >&2
			echo "    -U : show only commits by user" >&2
			echo "    -g : show only commits with log messages containing regex" >&2
			echo "    -R : show commits in reverse order (oldest to newest)" >&2
			echo "    -h : this help message" >&2
			echo "    user : either name or email; can be partial, but is case-sensitive" >&2
			echo "    file : source file (default: entire working tree)" >&2
			exit
			;;
		:)  echo "$me: $OPTARG requires an argument ($me -h for help)" >&2
			exit 2
			;;
		\?) echo "$me: unknown argument $OPTARG ($me -h for help)" >&2
			exit 2
			;;
	esac
done
shift $(( $OPTIND - 1 ))
   [[ $date_format == local ]] && args="$args --date=local"
   [[ $show_me     == 1     ]] && args="$args --author $(capture_git "config user.email")"
   [[ $show_merges == 0     ]] && args="$args --no-merges"
   [[ $show_local  == 1     ]] && args="$args -n$(how_many_unpushed)"
if [[ $show_branch == 1     ]]
then
	branch=$(current_branch)
	from=$(branched_from $branch)
	args="$args $from..$branch"
fi


cmd="$cmd $args $*"
if [[ -n $post ]]
then
	cmd="$cmd | $post"
fi

[[ -t 1 && $pretend == 0 ]] && echo -e "\n\n\n\n"
run_git "$cmd"
