#! /bin/bash

me=${0##*/}																# slightly prettier than $0
readonly me


function current_branch
{
	branch=$(git branch --contains HEAD | perl -lne 'print if s/^\* //')
	if [[ $branch == *"no branch"* ]]
	then
		echo "$me: can't show branch logs with a detached HEAD" >&2
		exit 1
	fi
	echo $branch
}

function branched_from
{
	git show-branch | perl -lne 'print $1 and exit if /^\s*\*[ -]*\+[ +-]*\s+\[([^^~]+).*?\]/'
}

cmd="git log"

args=''
verbose=0
pretend=0
date_format=local
while getopts ":vdcpbln:LU:g:Gh" opt
do
	case $opt in
		v)	verbose=1
			args="$args --stat"
			;;
		d)	args="$args -p"
			;;
		c)  args="$args --oneline"
			post="wc -l"
			;;
		p)	pretend=1
			;;
		b)	branch=$(current_branch)
			from=$(branched_from)
			args="$args $from..$branch"
			;;
		L)	pushed=origin/$(current_branch)
			if ! git show-ref --quiet $pushed
			then
				# perhaps this is a new branch, never pushed anywhere
				# let's try to find where it was branched from
				pushed=$(branched_from)
				if ! git show-ref --quiet $pushed
				then
					# WTF? it was branched from something that doesn't exist?
					# that should never happen
					echo "$me: branch never pushed and can't determine where branched from"
					exit 1
				fi
			fi
			args="$args $pushed..HEAD"
			;;
		l)	args="$args -n1"
			;;
		n)	args="$args -n$OPTARG"
			;;
		U)  args="$args --author $OPTARG"
			;;
		g)	args="$args --grep $OPTARG"
			;;
		G)	date_format=gmt
			;;
		h)  echo "usage: $me -h | [-vdG | -c] [-p] [-b | -L] [-l | -nX] [-Uuser] [-g regex] [file ...]" >&2
			echo "    -v : verbose (show files changed, include merge commits)" >&2
			echo "    -d : show diffs of changed files" >&2
			echo "    -G : display dates in GMT/UTC format" >&2
			echo "    -c : don't show commits, just count them" >&2
			echo "    -p : pretend (show git command to be run, but don't run it)" >&2
			echo "    -b : show only commits on the current branch (no merges unless -v)" >&2
			echo "    -L : show only commits not yet pushed to server (no merges unless -v)" >&2
			echo "    -l : show only latest commit (same as -n1)" >&2
			echo "    -n : show only X commits (default: show all)" >&2
			echo "    -U : show only commits by user" >&2
			echo "    -g : show only commits with log messages containing regex" >&2
			echo "    -h : this help message" >&2
			echo "    user : either name or email; can be partial, but is case-sensitive" >&2
			echo "    file : source file (default: entire working tree)" >&2
			exit
			;;
		:)  echo "$me: $OPTARG requires an argument ($me -h for help)" >&2
			exit 2
			;;
		\?) echo "$me: unknown argument $OPTARG ($me -h for help)" >&2
			exit 2
			;;
	esac
done
shift $(( $OPTIND - 1 ))
[[ $verbose == 0 ]] && args="$args --no-merges"
[[ $date_format == local ]] && args="$args --date=local"


cmd="$cmd $args $*"
if [[ -n $post ]]
then
	cmd="$cmd | $post"
fi

if [[ $pretend == 1 ]]
then
	echo "$me: would run"
	echo -e "\n    $cmd\n"
else
	echo -e "\n\n\n\n"
	eval $cmd
fi
