#! /usr/bin/env perl

use myperl::Script DEBUG => 1;
use autodie ':all';

use Getopt::Std;


sub process_timer($@);


opts <<'-';
	[-v] [-b] <ticket> <file> [...]
	-v : verbose mode
	-b : breakdown timers
	<ticket> ticket number (Jira or Trac)
	<file> timer file(s)
-

my $ticket = uc(shift);
die("don't recoginze Jira/Trac ticket num: $ticket")
		unless $ticket =~ /^\w{2,5}-\d{1,5}$/ or $ticket =~ /^\d{4,5}$/;;

die("must specify timer file(s)") unless @ARGV;


my $pipe_opened = 0;
foreach my $file (@ARGV)
{
	my @file = slurp $file;
	shift @file if $file[0] =~ /^$/;

	my $week = 1;
	my $newlines = 0;
	my (@current, @timers, @comments);
	foreach (@file)
	{
		if ( /^$/ )
		{
			++$newlines;
			if ($newlines == 1)
			{
				@timers = @current;
			}
			elsif ($newlines == 2)
			{
				@comments = @current;
				PROCESS:
				{
					my $timer_re = join('|', map { /^([\w-]+):/ }  grep { /\t$ticket(\t|$)/ } @comments);
					process_timer $file, $week => grep { /^($timer_re)\t/ } @timers;
				}
				$newlines = 0;
				++$week;
				@current = ();
			}
		}
		else
		{
			push @current, $_;
		}
	}
}

if ($pipe_opened)
{
	say PIPE '';
	say PIPE "foo:\tbar";		# doesn't really matter what you put here
	say PIPE '';
	close(PIPE);
}
else
{
	die("no timers matching ticket $ticket found\n");
}


sub process_timer ($@)
{
	my $file = shift;
	my $week = shift;

	foreach (@_)
	{
		my ($timer) = /^(.+?)\t/ or die("can't determine timer from line: $_");

		unless ($pipe_opened)
		{
			my $cmd = "fake_timer total $timer";
			debuggit(2 => "about to run:", $cmd);
			open(PIPE, "| $cmd");
			say PIPE '';
			$pipe_opened = 1;
		}

		print "$file: $_" if $OPT{'v'};
		print map { "$file: $_" } `fake_timer -w$week breakdown $timer $file` if $OPT{'b'};
		print PIPE s/$/\t$ticket/r;
	}
}
