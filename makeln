#! /bin/bash

source ./functions

# Probably $LOCALHOSTNAME is already set, but it's pretty tragic if it's not.  Better safe than
# sorry.  Note that this utilizes the same method that rc/tcshrc does.
: ${LOCALHOSTNAME:=`$mydir/root/lbin/localhostname`}


###########################
# MAIN
###########################


[[ $TCSHRC_DEBUG ]] && echo "mklnDEBUG: starting main"

if [[ $PWD != $mydir ]]
then
	echo "sorry; must run from ~/common" >&2
	exit 1
fi

# make sure we have the dirs we need (useful for a brand-spanking-new homedir)
[[ -d ~/.ssh ]] || mkdir ~/.ssh
[[ -d ~/.unison ]] || mkdir ~/.unison

# do rc's first; they're moderately straightforward except for having to add
# . in front of the name ... these all go in ~
cd $mydir/rc
for file in *
do
	make_link $mydir/rc/$file $HOME/.$file
done

# do localhost rc's, if any
local_rcdir=$mydir/local/$LOCALHOSTNAME/rc
if [[ -d $local_rcdir ]]
then
	cd $local_rcdir
	for file in *
	do
		dest=$HOME/.$file
		# don't allow local rc's to overwrite, even with confirmation
		if [[ -e $dest && ! $local_rcdir/$file -ef $dest ]]
		then
			echo "WARNING! will not overwrite $dest with local link; skipping" >&2
		else
			make_link $local_rcdir/$file $dest
		fi
	done
fi

[[ $TCSHRC_DEBUG ]] && echo "mklnDEBUG: built simple rc's"

# do pidgin.layout, if any
p_layout=$mydir/local/$LOCALHOSTNAME/data/pidgin.layout
if [[ -f $p_layout ]]
then
	dest=$HOME/local/data/pidgin.layout
	make_link $p_layout $dest
fi

# .dzil dir will be built in three parts:
#	# the directory itself will be made if it's not there
#		(it can't be a symlink because it needs to contains files symlinked from
#		two different places)
#	# publicly available stuff from $mydir/dzil
#	# the config.ini, which contains passwords and therefore isn't public-facing
#		(that will be symlinked by the "sensitive" section, below)
[[ -d ~/.dzil ]] || mkdir ~/.dzil
cd $mydir/dzil
for file in *
do
	make_link $mydir/dzil/$file $HOME/.dzil/$file
done

# .vctools dir is a bit like .dzil, only (mostly) simpler
# the only tricky bit is that the main vctools.conf file *might* have a
# host-specific override
if [[ $1 != refresh ]]
then
	[[ -d ~/.vctools ]] || mkdir ~/.vctools
	cd $mydir/vctools
	if [[ -r vctools.conf.$LOCALHOSTNAME ]]
	then
		make_link $mydir/vctools/vctools.conf.$LOCALHOSTNAME $HOME/.vctools/vctools.conf
	elif [[ -r vctools.conf.$HOST ]]
	then
		make_link $mydir/vctools/vctools.conf.$HOST $HOME/.vctools/vctools.conf
	else
		make_copy vctools.conf $HOME/.vctools/vctools.conf
	fi
	for file in *
	do
		if [[ $file != vctools.conf* ]]
		then
			make_link $mydir/vctools/$file $HOME/.vctools/$file
		fi
	done
fi

# we have a few rc's in a separate place because they have passwords in them
alt_rcdir=~/Dropbox/sensitive
if [[ -d $alt_rcdir ]]
then
	cd $alt_rcdir
	for file in *
	do
		if [[ -f $file ]]							# skip directories
		then
			if [[ ${file/-/} != $file ]]
			then
				# there's a dash in it ... that means it goes underneath another dot-dir
				lnfile=${file//-/\/}
			else
				lnfile=$file
			fi
			make_link $alt_rcdir/$file $HOME/.$lnfile
		fi
	done
fi

[[ $TCSHRC_DEBUG ]] && echo "mklnDEBUG: constructed special rc's"

# for bin, what we really want is for the whole directory to be symlinked
# this makes it easy to add new commands
# if there's already a directory there, though, we dare not just delete it
dir=~/bin
if [[ -d $dir && ! -L $dir ]]
then
	echo "$0: your $dir directory is a real directory instead of a symlink" >&2
	echo "$0: please fix that and rerun" >&2
	exit 1
fi
make_link $mydir/bin $dir

# ditto for .cddb, only not as tragic if the dir already exists
# also not as tragic if we can't find it, since it isn't here in $mydir any more
if [[ $1 != refresh && -d ~/Dropbox ]]
then
	dir=~/.cddb
	if [[ -d $dir ]]
	then
		if [[ ! -L $dir ]]
		then
			echo "$0: your $dir directory is a real directory instead of a symlink" >&2
			echo "$0: please fix that before you rerun" >&2
		fi
	else
		srcdir=$(find_dir ~/Dropbox/music/cddb $mydir/cddb)
		if [[ -d $srcdir ]]
		then
			make_link $srcdir $dir
		fi
	fi
fi

# dirs to symlink in from Dropbox
if [[ $1 != refresh && -d ~/Dropbox ]]
then
	for src_dir in ~/Dropbox/proj ~/Dropbox/rpg ~/Dropbox/work/timer
	do
		dest_dir=~/${src_dir##*/}
		if [[ -d $dir && ! -L $dir ]]
		then
			echo "$0: your $dir directory is a real directory instead of a symlink" >&2
			echo "$0: please fix that and rerun" >&2
			exit 1
		fi
		make_link $src_dir $dest_dir
	done
	# this one gets renamed when linked
	make_link ~/Dropbox/personal ~/docs
fi

# dirs to symlink in from Dropbox as dot-dirs
if [[ $1 != refresh && -d ~/Dropbox ]]
then
	for dir in purple cpan-testers
	do
		dbdir=~/.$dir
		if [[ -d $dbdir && ! -L $dbdir ]]
		then
			echo "$0: your $dbdir directory is a real directory instead of a symlink" >&2
			echo "$0: please fix that and rerun" >&2
			exit 1
		fi
		make_link ~/Dropbox/$dir $dbdir
	done
fi

[[ $TCSHRC_DEBUG ]] && echo "mklnDEBUG: symlinked dirs"

# Dropbox "local" dirs
if [[ $1 != refresh && -d ~/Dropbox ]]
then
	local_dbdir=~/Dropbox/machine/$LOCALHOSTNAME
	[[ -d $local_dbdir ]] || mkdir -p $local_dbdir
	# Dropbox dir is just a copy of local dir
	# (copying handled by crontab, set up below)
	for dir in firefox mozilla config thunderbird
	do
		[[ -d $local_dbdir/$dir ]] || mkdir -p $local_dbdir/$dir
	done
fi

# stuff to symlink in from ~/Dropbox/personal
if [[ $1 != refresh && -d ~/Dropbox ]]
then
	for dir in ~/vimS ~/.local/share/tomboy
	do
		if [[ -d $dir && ! -L $dir ]]
		then
			echo "$0: your $dir directory is a real directory instead of a symlink" >&2
			echo "$0: please fix that and rerun" >&2
			exit 1
		fi
		srcdir=~/Dropbox/personal/$(basename $dir)
		make_link $srcdir $dir
	done
fi

# Unison configuration files
# just symlink in what we've got
if [[ -d $mydir/unison ]]
then
	cd $mydir/unison
	for file in *
	do
		make_link $mydir/unison/$file $HOME/.unison/$file
	done
fi

# we're going to take this opportunity to build the index files that fortune needs, but there's
# always the possibility that we can't find strfile, so let's make a guess as to that too
strfile=$(which strfile 2>/dev/null)
if [[ -z $strfile ]]
then
	if [[ -x /usr/sbin/strfile ]]
	then
		strfile=/usr/sbin/strfile
	fi
fi
# if we couldn't find strfile at this point, there isn't much point in doing
# the fortune files, so we'll just skip it
if [[ -n $strfile ]]
then
	# fortune files will occasionally sit in /usr/local/fortunes
	# however, these days it's more likely in ~/local/fortunes instead
	dir=$(find_dir ~/local/fortunes /usr/local/fortunes)
	if [[ -d $dir ]]
	then
		cd $mydir/fortunes
		for file in *
		do
			make_link $mydir/fortunes/$file $dir/$file
			cd $dir
			if [[ -L $file.dat ]]
			then
				/bin/rm -f $file.dat
			fi
			if [[ ! -e $file.dat || $file -nt $file.dat ]]
			then
				$strfile $file
			fi
		done
	fi
fi


# now the special ones:

# 1: .screenrc.base
# if this file exists, don't mess with it
# if not, supply a useful default
if [[ ! -e ~/.screenrc.base ]]
then
	cat >~/.screenrc.base <<END
bind ^_ source .screenrc.search
bind ^v source .screenrc.vctools

screen -t base
screen -t timer
	stuff "timer\015"
screen -t man
	stuff "man screen\015"
screen -t top top
screen -t root sudo su -
END
fi

# 2: .ssh/config
# the pieces of this file are in little chunks
# if the file is completely missing, start if off with the base config
# for each chunk, we need to know if that chunk is already in the config file
# if it is, do nothing
# if it isn't, add it
ssh_config=~/.ssh/config
cd $mydir
[[ -r $ssh_config ]] || cp ssh/config $ssh_config
for file in ssh/config.*
do
	host=${file#ssh/config.}
	if ! egrep -q "Host[ 	]+$host" ~/.ssh/config 2>/dev/null
	then
		if [[ -n $(resolve_host $host) ]]
		then
			# if we can resolve the host already, don't use the HostName line
			# this will help with hosts that can be either remote or on the local network
			grep -v HostName $file >>$ssh_config
		else
			cat $file >>$ssh_config
		fi
	fi
done

# 3: .ssh/authorized_keys
# each public key needs to be put into authorized keys, but not if it's already there
cd $mydir
authfile=~/.ssh/authorized_keys
for file in ssh/*.pub
do
	replace_in_file $authfile $file '{print $3}'
done

# 4: .ssh/known_hosts
# similar to authorized_keys, but for known_hosts
cd $mydir
knownfile=~/.ssh/known_hosts
for file in ssh/*.known
do
	replace_in_file $knownfile $file '$1 != "#" {print $1}'
done

# 5: .ssh/
# may as well go ahead and fix the perms on this dir since little will
# actually work unless the perms are correct
chmod -R go-rwx ~/.ssh


#################################
# Install crontab
# (but not on Vagrant sandboxes!)
#################################

if [[ $(id -un) != "vagrant" ]]
then
	tmp_crontab=$(mktemp)
	trap "/bin/rm -f $tmp_crontab" EXIT
	my_crondir=$mydir/conf/crontab
	cat $my_crondir/default.cron >$tmp_crontab
	machine_cron=$my_crondir/$LOCALHOSTNAME.cron
	if [[ -e $machine_cron ]]
	then
		cat $machine_cron >>$tmp_crontab
	fi
	if ! diff <(crontab -l) $tmp_crontab >/dev/null
	then
		echo "updating crontab" >&2
		crontab $tmp_crontab
	fi
fi


###########################
# Subscripts
###########################

[[ -d /export ]] && ./build-music					# don't try to build if there's /export (e.g. a sandbox)
