#! /bin/bash -e
. ~/bin/bash_funcs

tarfile=$1
[[ $tarfile ]] || die "must supply tarfile name/pattern"
opts=":$2:"

# make sure we have creds before we get too far in
$CEROOT/devtools/aws-credentials-check

ferrydir=/var/tmp/ferry
mkdir -p $ferrydir

[[ $tarfile == "s3://"* ]] || tarfile=$(ferry-ls -l "$tarfile")
[[ $tarfile ]] || die "ferry file /$1/ doesn't exist"
[[ $(echo "$tarfile" | wc -l) == 1 ]] || die "too many candidates! [$tarfile]"

patchdir=tmp/patches
if [[ -e $patchdir ]]
then
	die "$patchdir already exists; left over from prior run?"
fi

aws s3 cp $tarfile $ferrydir
tarfile=$ferrydir/$(basename $tarfile)
trap "/bin/rm -f $tarfile" EXIT

if [[ $(vc info %is_dirty) == 1 ]]
then
	tmpfile=$(mktemp)
	trap "/bin/rm -f $tarfile $tmpfile" EXIT
	vc clean -y | tee $tmpfile
	dirty_restore=$(perl -lne '/^Dropped.*\((\w+)\)/ and print $1' $tmpfile)
	color_msg_block $CYAN "dirty_restore: $dirty_restore"
fi

old_head=$(git rev-parse HEAD)
color_msg_block $CYAN "old_head: $old_head"
first_unpushed=$(vc info %local_commits | tail -n1)
if [[ $first_unpushed ]]
then
	branched_from=$(git rev-parse $first_unpushed^)
fi

tar xvpzf $tarfile

if [[ -d $patchdir ]]
then
	if [[ $branched_from ]]
	then
		git reset --hard $branched_from
	fi
	vc clean -y ||:
	cur_branch=$(vc info %cur_branch)
	if [[ $cur_branch == feature/* ]]
	then
		if ! vc branch-update
		then
			echo -n "possible merge conflict; resolve and resume [ENTER to continue ...] "
			read
		fi
	elif [[ $cur_branch == $(vc info %Mainline) ]]
	then
		vc sync
	fi
	git am $patchdir/*
	# since we did another `vc clean`, our non-patch changes got lost
	# so just unpack the tarfile again to get them back
	tar xvpzf $tarfile
	[[ $opts == *":keep:"* ]] || /bin/rm -rf $patchdir
fi

echo -e "\n\n\n"
echo "to restore your repo to its pre-unferry state, do this:" >&2
cmds=()
[[ $(git status | grep 'in the middle of an am session') ]] && cmds+=("git am --abort")
cmds+=("vc clean -y")
cmds+=("git reset --hard $old_head")
[[ $dirty_restore ]] && cmds+=("git stash apply $dirty_restore")
color_msg_block $BOLD "${cmds[@]}"
