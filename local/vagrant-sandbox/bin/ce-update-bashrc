#! /usr/local/bin/launch bash -*PROJ:archer-boot -*DEVOPS
bashlib-demand ssh

host=$1 ; shift
host=$(archer-hostname $host)
function cessh { $ABOOTROOT/devtools/archer-ssh "$@" ; }
function cescp { $ABOOTROOT/devtools/archer-scp "$@" ; }

instance_id=$(cessh $host ec2metadata --instance-id)
hostclass=$(ec2-tag $instance_id class)
screen=monitor										# most machines are used for monitoring something
[[ $hostclass == dirk* ]] && screen=logs			# but dirk is special in a couple of ways
[[ $hostclass == quin* ]] && screen=push			# and quin's are even special-er
echo "# setting up for: $screen"

if ! cessh $host cat .bashrc | grep -q "^export CURRENT_SCREEN="
then
	cat <<END | cessh $host cat ">>.bashrc"

export CE_REMOTE_USERNAME=bburden
export PERL5LIB=\$CEROOT/lib:\$CEROOT/extlib/lib/perl5
[[ \$PATH == *\$HOME/bin* ]] || export PATH=\$PATH:\$HOME/bin
export PAGER="$PAGER"
export CURRENT_SCREEN=$screen
alias sr='screen -A -x \$CURRENT_SCREEN'
END
fi

# make aliases
cat <<'END' | cessh $host cat ">.bash_aliases"
alias go='sudo -H -u CE -- sh -c "cd $PWD ; exec $SHELL -l"'
alias resrc='source ~/.bashrc'
alias ssh-sock-reset='source ~/bin/ssh-sock-reset'
END

# make vim behave sanely
cescp -p ~/.exrc $host:

if [[ $(cessh $host ls ".screenrc*" 2>/dev/null | wc -l) -lt 2 ]]
then
	cescp ~/common/rc/screenrc         $host:.screenrc
	cescp ~/common/rc/screenrc.$screen $host:.screenrc.$screen
fi

# this gets us whatever helper scripts we have created
cessh -Q $host bash -c 'mkdir -p bin/ ; chgrp CE bin ; chmod g+w bin'
launch LOCAL archer-rsync -v $CHEOPSROOT/launch-ec2/control-instance/bin/* $host:bin/

# set up for pjawk, but only on dirk
if [[ $screen == "logs" ]]
then
	cescp $(find ~/common/ -name build-pjawk) $host:bin/
fi
